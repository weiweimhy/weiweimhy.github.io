[{"content":"数值类型 整数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 // 有符号整数 var i8 int8 // -128 到 127 var i16 int16 // -32768 到 32767 var i32 int32 // -2147483648 到 2147483647 var i64 int64 // -9223372036854775808 到 9223372036854775807 var i int // 32位或64位，取决于系统 // 无符号整数 var u8 uint8 // 0 到 255 var u16 uint16 // 0 到 65535 var u32 uint32 // 0 到 4294967295 var u64 uint64 // 0 到 18446744073709551615 var u uint // 32位或64位，取决于系统 浮点数类型 1 2 3 var f32 float32 // 32位浮点数 var f64 float64 // 64位浮点数 var f float // float64 的别名 复数类型 1 2 3 var c64 complex64 // 64位复数 var c128 complex128 // 128位复数 var c complex // complex128 的别名 字符串 字符串特性 字符串是不可变的 支持 UTF-8 编码 可以使用反引号创建原始字符串 字符串操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 字符串声明 var s1 string = \u0026#34;Hello\u0026#34; s2 := \u0026#34;World\u0026#34; // 原始字符串 s3 := `This is a raw string with multiple lines` // 字符串连接 s4 := s1 + \u0026#34; \u0026#34; + s2 // 字符串长度 length := len(s1) // 字符串切片 sub := s1[1:3] // \u0026#34;el\u0026#34; 布尔类型 布尔值 1 2 3 4 5 6 7 var b1 bool = true var b2 bool = false // 布尔运算 b3 := true \u0026amp;\u0026amp; false // 与 b4 := true || false // 或 b5 := !true // 非 类型转换 数值类型转换 1 2 3 4 5 6 7 8 9 10 11 // 整数转换 var i int = 42 var f float64 = float64(i) // 浮点数转换 var f2 float64 = 3.14 var i2 int = int(f2) // 截断小数部分 // 字符串转换 var s string = strconv.Itoa(42) // 整数转字符串 i3, _ := strconv.Atoi(\u0026#34;42\u0026#34;) // 字符串转整数 常量 常量声明 1 2 3 4 5 6 7 8 9 10 11 12 13 // 单个常量 const Pi = 3.14159 // 多个常量 const ( Sunday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) 参考资源 Go 语言规范 Go 基础类型文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/5.-go-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"5. Go 基础数据类型"},{"content":"数组 数组比较 数组比较时，首先比较数组长度 如果数组长度相同并且每个元素都相同，则两个数组相等 不同数据类型的数组比较会报编译错误 数组作为参数 数组作为参数传递时会复制整个数组 函数内对数组的操作都是针对复制体 传递大数组时效率较低 可以通过指针传递数组以提高效率 1 2 3 4 5 6 7 8 9 10 // 使用指针传递数组 func zero(ptr *[32]byte) { *ptr = [32]byte{} } // 使用示例 func main() { var arr [32]byte zero(\u0026amp;arr) } 切片 切片特性 切片是对数组的引用 切片可以动态增长 切片作为参数传递时只传递引用 切片操作 1 2 3 4 5 6 7 8 // 创建切片 s := make([]int, 5, 10) // 长度为5，容量为10的切片 // 追加元素 s = append(s, 1, 2, 3) // 截取切片 s1 := s[1:3] // 包含索引1，不包含索引3 Map Map 特性 Map 是引用类型，零值为 nil Map 不是并发安全的，需要加锁保护 Map 的键必须是可比较的类型 Map 的迭代顺序是随机的 Map 操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 创建 map m := make(map[string]int) // 添加或更新键值对 m[\u0026#34;key\u0026#34;] = 1 // 删除键值对 delete(m, \u0026#34;key\u0026#34;) // 检查键是否存在 if value, ok := m[\u0026#34;key\u0026#34;]; ok { fmt.Printf(\u0026#34;值: %d\\n\u0026#34;, value) } // 并发安全的 map var syncMap sync.Map syncMap.Store(\u0026#34;key\u0026#34;, 1) value, _ := syncMap.Load(\u0026#34;key\u0026#34;) Channel Channel 特性 Channel 是引用类型，零值为 nil Channel 必须使用 make 创建 Channel 可以是有缓冲或无缓冲的 关闭后的 channel 仍然可以读取数据 Channel 操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 创建无缓冲 channel ch := make(chan int) // 创建有缓冲 channel ch := make(chan int, 10) // 发送数据 ch \u0026lt;- 1 // 接收数据 value := \u0026lt;-ch // 关闭 channel close(ch) // 遍历 channel for v := range ch { fmt.Println(v) } 指针 指针特性 指针可以指向任何类型的变量 指针的零值是 nil 指针可以用于修改原变量的值 指针使用 1 2 3 4 5 // 指针声明和使用 var p *int i := 42 p = \u0026amp;i *p = 21 // 通过指针修改值 结构体 结构体特性 结构体字段可以导出（首字母大写） 结构体可以嵌入其他结构体 结构体可以实现接口 结构体示例 1 2 3 4 5 6 7 8 9 type Person struct { Name string Age int } // 结构体方法 func (p *Person) SetAge(age int) { p.Age = age } 接口 接口特性 接口是隐式实现的 接口可以组合 空接口可以存储任何类型的值 接口示例 1 2 3 4 5 6 7 8 9 10 11 12 13 type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } // 接口组合 type ReadWriter interface { Reader Writer } 参考资源 Go 语言规范 Go 数据类型文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/6.-go-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","title":"6. Go 数据类型注意事项"},{"content":"文件操作基础 打开文件 1 2 3 4 5 6 7 8 9 10 11 12 13 // 打开文件 file, err := os.Open(\u0026#34;example.txt\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() // 创建文件 file, err := os.Create(\u0026#34;newfile.txt\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() 读取文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 读取整个文件 data, err := os.ReadFile(\u0026#34;example.txt\u0026#34;) if err != nil { log.Fatal(err) } // 按行读取 file, err := os.Open(\u0026#34;example.txt\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { line := scanner.Text() fmt.Println(line) } 写入文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 写入字符串 err := os.WriteFile(\u0026#34;output.txt\u0026#34;, []byte(\u0026#34;Hello, World!\u0026#34;), 0644) if err != nil { log.Fatal(err) } // 追加写入 file, err := os.OpenFile(\u0026#34;output.txt\u0026#34;, os.O_APPEND|os.O_WRONLY, 0644) if err != nil { log.Fatal(err) } defer file.Close() _, err = file.WriteString(\u0026#34;追加的内容\u0026#34;) if err != nil { log.Fatal(err) } 目录操作 创建目录 1 2 3 4 5 6 7 8 9 10 11 // 创建单个目录 err := os.Mkdir(\u0026#34;newdir\u0026#34;, 0755) if err != nil { log.Fatal(err) } // 创建多级目录 err := os.MkdirAll(\u0026#34;path/to/dir\u0026#34;, 0755) if err != nil { log.Fatal(err) } 遍历目录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 读取目录内容 entries, err := os.ReadDir(\u0026#34;.\u0026#34;) if err != nil { log.Fatal(err) } for _, entry := range entries { fmt.Println(entry.Name()) } // 递归遍历目录 func walkDir(dir string) { entries, err := os.ReadDir(dir) if err != nil { log.Fatal(err) } for _, entry := range entries { path := filepath.Join(dir, entry.Name()) if entry.IsDir() { walkDir(path) } else { fmt.Println(path) } } } 文件信息 获取文件信息 1 2 3 4 5 6 7 8 9 10 // 获取文件信息 fileInfo, err := os.Stat(\u0026#34;example.txt\u0026#34;) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;文件名: %s\\n\u0026#34;, fileInfo.Name()) fmt.Printf(\u0026#34;大小: %d bytes\\n\u0026#34;, fileInfo.Size()) fmt.Printf(\u0026#34;修改时间: %v\\n\u0026#34;, fileInfo.ModTime()) fmt.Printf(\u0026#34;权限: %v\\n\u0026#34;, fileInfo.Mode()) 检查文件状态 1 2 3 4 5 6 7 8 9 // 检查文件是否存在 if _, err := os.Stat(\u0026#34;example.txt\u0026#34;); os.IsNotExist(err) { fmt.Println(\u0026#34;文件不存在\u0026#34;) } // 检查是否是目录 if fileInfo.IsDir() { fmt.Println(\u0026#34;这是一个目录\u0026#34;) } 临时文件 创建临时文件 1 2 3 4 5 6 7 8 9 10 11 12 // 创建临时文件 tmpFile, err := os.CreateTemp(\u0026#34;\u0026#34;, \u0026#34;example-*.txt\u0026#34;) if err != nil { log.Fatal(err) } defer os.Remove(tmpFile.Name()) // 写入临时文件 content := []byte(\u0026#34;临时文件内容\u0026#34;) if _, err := tmpFile.Write(content); err != nil { log.Fatal(err) } 文件路径操作 路径处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 路径拼接 path := filepath.Join(\u0026#34;dir\u0026#34;, \u0026#34;subdir\u0026#34;, \u0026#34;file.txt\u0026#34;) // 获取绝对路径 absPath, err := filepath.Abs(\u0026#34;relative/path\u0026#34;) if err != nil { log.Fatal(err) } // 获取文件扩展名 ext := filepath.Ext(\u0026#34;file.txt\u0026#34;) // 获取文件名（不含扩展名） name := strings.TrimSuffix(\u0026#34;file.txt\u0026#34;, filepath.Ext(\u0026#34;file.txt\u0026#34;)) 参考资源 Go os 包文档 Go filepath 包文档 Go bufio 包文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/7.-go-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","title":"7. Go 文件操作"},{"content":"Goroutine 基本概念 Goroutine 是轻量级线程 由 Go 运行时管理 比线程更高效 创建和使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 启动 goroutine go func() { fmt.Println(\u0026#34;在 goroutine 中运行\u0026#34;) }() // 带参数的 goroutine go func(msg string) { fmt.Println(msg) }(\u0026#34;Hello\u0026#34;) // 等待 goroutine 完成 var wg sync.WaitGroup wg.Add(1) go func() { defer wg.Done() fmt.Println(\u0026#34;goroutine 完成\u0026#34;) }() wg.Wait() Channel Channel 类型 1 2 3 4 5 6 7 8 9 10 11 // 无缓冲 channel ch1 := make(chan int) // 有缓冲 channel ch2 := make(chan int, 10) // 只读 channel ch3 := make(\u0026lt;-chan int) // 只写 channel ch4 := make(chan\u0026lt;- int) Channel 操作 1 2 3 4 5 6 7 8 9 10 11 12 13 // 发送数据 ch \u0026lt;- 42 // 接收数据 value := \u0026lt;-ch // 关闭 channel close(ch) // 遍历 channel for v := range ch { fmt.Println(v) } 同步原语 WaitGroup 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var wg sync.WaitGroup func worker(id int) { defer wg.Done() fmt.Printf(\u0026#34;Worker %d 开始\\n\u0026#34;, id) time.Sleep(time.Second) fmt.Printf(\u0026#34;Worker %d 完成\\n\u0026#34;, id) } func main() { for i := 1; i \u0026lt;= 5; i++ { wg.Add(1) go worker(i) } wg.Wait() } Mutex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type SafeCounter struct { mu sync.Mutex count int } func (c *SafeCounter) Increment() { c.mu.Lock() defer c.mu.Unlock() c.count++ } func (c *SafeCounter) GetCount() int { c.mu.Lock() defer c.mu.Unlock() return c.count } RWMutex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type SafeMap struct { mu sync.RWMutex data map[string]interface{} } func (m *SafeMap) Get(key string) interface{} { m.mu.RLock() defer m.mu.RUnlock() return m.data[key] } func (m *SafeMap) Set(key string, value interface{}) { m.mu.Lock() defer m.mu.Unlock() m.data[key] = value } 并发模式 工作池模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func worker(id int, jobs \u0026lt;-chan int, results chan\u0026lt;- int) { for j := range jobs { fmt.Printf(\u0026#34;worker %d 开始处理任务 %d\\n\u0026#34;, id, j) time.Sleep(time.Second) results \u0026lt;- j * 2 fmt.Printf(\u0026#34;worker %d 完成任务 %d\\n\u0026#34;, id, j) } } func main() { jobs := make(chan int, 100) results := make(chan int, 100) // 启动工作池 for w := 1; w \u0026lt;= 3; w++ { go worker(w, jobs, results) } // 发送任务 for j := 1; j \u0026lt;= 9; j++ { jobs \u0026lt;- j } close(jobs) // 收集结果 for a := 1; a \u0026lt;= 9; a++ { fmt.Println(\u0026lt;-results) } } 发布订阅模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type PubSub struct { mu sync.RWMutex subs map[string][]chan string } func NewPubSub() *PubSub { return \u0026amp;PubSub{ subs: make(map[string][]chan string), } } func (ps *PubSub) Subscribe(topic string) chan string { ps.mu.Lock() defer ps.mu.Unlock() ch := make(chan string) ps.subs[topic] = append(ps.subs[topic], ch) return ch } func (ps *PubSub) Publish(topic string, msg string) { ps.mu.RLock() defer ps.mu.RUnlock() for _, ch := range ps.subs[topic] { go func(ch chan string) { ch \u0026lt;- msg }(ch) } } 并发安全 原子操作 1 2 3 4 5 6 7 8 9 var counter int64 func increment() { atomic.AddInt64(\u0026amp;counter, 1) } func getCounter() int64 { return atomic.LoadInt64(\u0026amp;counter) } 并发安全的 Map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var syncMap sync.Map // 存储键值对 syncMap.Store(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) // 加载值 value, ok := syncMap.Load(\u0026#34;key\u0026#34;) // 删除键值对 syncMap.Delete(\u0026#34;key\u0026#34;) // 遍历 syncMap.Range(func(key, value interface{}) bool { fmt.Printf(\u0026#34;%v: %v\\n\u0026#34;, key, value) return true }) 参考资源 Go 并发编程 Go sync 包文档 Go atomic 包文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/8.-go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","title":"8. Go 并发编程"},{"content":"HTTP 客户端 基本请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // GET 请求 resp, err := http.Get(\u0026#34;https://api.example.com/data\u0026#34;) if err != nil { log.Fatal(err) } defer resp.Body.Close() // 读取响应 body, err := io.ReadAll(resp.Body) if err != nil { log.Fatal(err) } fmt.Println(string(body)) // POST 请求 data := []byte(`{\u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;}`) resp, err = http.Post(\u0026#34;https://api.example.com/create\u0026#34;, \u0026#34;application/json\u0026#34;, bytes.NewBuffer(data)) if err != nil { log.Fatal(err) } defer resp.Body.Close() 自定义请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 创建请求 req, err := http.NewRequest(\u0026#34;POST\u0026#34;, \u0026#34;https://api.example.com/data\u0026#34;, bytes.NewBuffer(data)) if err != nil { log.Fatal(err) } // 设置请求头 req.Header.Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) req.Header.Set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer token\u0026#34;) // 发送请求 client := \u0026amp;http.Client{} resp, err := client.Do(req) if err != nil { log.Fatal(err) } defer resp.Body.Close() HTTP 服务器 基本服务器 1 2 3 4 5 6 7 8 func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello, %s!\u0026#34;, r.URL.Path[1:]) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } 路由处理 1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;首页\u0026#34;) }) mux.HandleFunc(\u0026#34;/api\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;API 页面\u0026#34;) }) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, mux)) } 中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func loggingMiddleware(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { start := time.Now() next.ServeHTTP(w, r) log.Printf(\u0026#34;%s %s %v\u0026#34;, r.Method, r.URL.Path, time.Since(start)) }) } func main() { mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, handler) // 使用中间件 handler := loggingMiddleware(mux) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, handler)) } WebSocket WebSocket 服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 var upgrader = websocket.Upgrader{ ReadBufferSize: 1024, WriteBufferSize: 1024, CheckOrigin: func(r *http.Request) bool { return true // 允许所有来源 }, } func handleWebSocket(w http.ResponseWriter, r *http.Request) { conn, err := upgrader.Upgrade(w, r, nil) if err != nil { log.Println(err) return } defer conn.Close() for { messageType, message, err := conn.ReadMessage() if err != nil { log.Println(err) break } // 发送响应 err = conn.WriteMessage(messageType, message) if err != nil { log.Println(err) break } } } func main() { http.HandleFunc(\u0026#34;/ws\u0026#34;, handleWebSocket) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } WebSocket 客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { conn, _, err := websocket.DefaultDialer.Dial(\u0026#34;ws://localhost:8080/ws\u0026#34;, nil) if err != nil { log.Fatal(err) } defer conn.Close() // 发送消息 err = conn.WriteMessage(websocket.TextMessage, []byte(\u0026#34;Hello!\u0026#34;)) if err != nil { log.Fatal(err) } // 接收消息 _, message, err := conn.ReadMessage() if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;收到消息: %s\\n\u0026#34;, message) } TCP 服务器 TCP 服务器示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 func handleConnection(conn net.Conn) { defer conn.Close() buffer := make([]byte, 1024) for { n, err := conn.Read(buffer) if err != nil { log.Println(err) return } // 发送响应 _, err = conn.Write(buffer[:n]) if err != nil { log.Println(err) return } } } func main() { listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8080\u0026#34;) if err != nil { log.Fatal(err) } defer listener.Close() for { conn, err := listener.Accept() if err != nil { log.Println(err) continue } go handleConnection(conn) } } TCP 客户端示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:8080\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() // 发送数据 _, err = conn.Write([]byte(\u0026#34;Hello, Server!\u0026#34;)) if err != nil { log.Fatal(err) } // 接收响应 buffer := make([]byte, 1024) n, err := conn.Read(buffer) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;收到响应: %s\\n\u0026#34;, buffer[:n]) } 参考资源 Go net 包文档 Go net/http 包文档 Go gorilla/websocket 包文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/9.-go-%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C/","title":"9. Go 网络操作"},{"content":"flag 包简介 flag 包是 Go 标准库中用于解析命令行参数的包。它提供了简单而强大的命令行参数处理功能。\n基本用法 定义参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) // 定义命令行参数 var ( name = flag.String(\u0026#34;name\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;用户名称\u0026#34;) age = flag.Int(\u0026#34;age\u0026#34;, 0, \u0026#34;用户年龄\u0026#34;) verbose = flag.Bool(\u0026#34;v\u0026#34;, false, \u0026#34;是否显示详细信息\u0026#34;) ) func main() { // 解析命令行参数 flag.Parse() // 使用参数 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, *name) fmt.Printf(\u0026#34;Age: %d\\n\u0026#34;, *age) fmt.Printf(\u0026#34;Verbose: %v\\n\u0026#34;, *verbose) } 运行示例 1 2 3 4 5 6 7 8 # 使用默认值 go run main.go # 指定参数 go run main.go -name \u0026#34;John\u0026#34; -age 25 -v # 查看帮助信息 go run main.go -help 高级用法 自定义参数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 自定义时间类型 type timeValue time.Time func (t *timeValue) String() string { return time.Time(*t).Format(time.RFC3339) } func (t *timeValue) Set(value string) error { parsed, err := time.Parse(time.RFC3339, value) if err != nil { return err } *t = timeValue(parsed) return nil } func main() { var t timeValue flag.Var(\u0026amp;t, \u0026#34;time\u0026#34;, \u0026#34;设置时间 (RFC3339格式)\u0026#34;) flag.Parse() fmt.Printf(\u0026#34;Time: %v\\n\u0026#34;, time.Time(t)) } 子命令支持 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 创建子命令 addCmd := flag.NewFlagSet(\u0026#34;add\u0026#34;, flag.ExitOnError) listCmd := flag.NewFlagSet(\u0026#34;list\u0026#34;, flag.ExitOnError) // 定义子命令参数 addName := addCmd.String(\u0026#34;name\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;添加项目名称\u0026#34;) listAll := listCmd.Bool(\u0026#34;all\u0026#34;, false, \u0026#34;列出所有项目\u0026#34;) // 检查子命令 if len(os.Args) \u0026lt; 2 { fmt.Println(\u0026#34;需要指定子命令: add 或 list\u0026#34;) os.Exit(1) } switch os.Args[1] { case \u0026#34;add\u0026#34;: addCmd.Parse(os.Args[2:]) fmt.Printf(\u0026#34;添加项目: %s\\n\u0026#34;, *addName) case \u0026#34;list\u0026#34;: listCmd.Parse(os.Args[2:]) fmt.Printf(\u0026#34;列出所有项目: %v\\n\u0026#34;, *listAll) default: fmt.Println(\u0026#34;未知的子命令\u0026#34;) os.Exit(1) } } 常用函数 flag.String(): 定义字符串参数 flag.Int(): 定义整数参数 flag.Bool(): 定义布尔参数 flag.Float64(): 定义浮点数参数 flag.Duration(): 定义时间间隔参数 flag.Var(): 定义自定义类型参数 flag.Parse(): 解析命令行参数 flag.Usage(): 显示帮助信息 参考资源 Go flag 包文档 Go 命令行参数处理 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/go-flag-%E5%8C%85%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Go flag 包使用指南"},{"content":"控制台输入方法 Go 语言提供了多种处理控制台输入的方法，每种方法都有其特点和适用场景。\n1. fmt.Scan 系列 fmt.Scan 系列函数是最简单的输入方法，适合简单的输入场景。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; func main() { var name string var age int // 读取字符串 fmt.Print(\u0026#34;请输入姓名: \u0026#34;) fmt.Scan(\u0026amp;name) // 读取整数 fmt.Print(\u0026#34;请输入年龄: \u0026#34;) fmt.Scan(\u0026amp;age) fmt.Printf(\u0026#34;姓名: %s, 年龄: %d\\n\u0026#34;, name, age) } 2. bufio.Scanner bufio.Scanner 提供了更灵活的输入处理方式，适合处理多行输入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { scanner := bufio.NewScanner(os.Stdin) // 读取一行 fmt.Print(\u0026#34;请输入姓名: \u0026#34;) scanner.Scan() name := scanner.Text() // 读取整数 fmt.Print(\u0026#34;请输入年龄: \u0026#34;) scanner.Scan() age, _ := strconv.Atoi(scanner.Text()) fmt.Printf(\u0026#34;姓名: %s, 年龄: %d\\n\u0026#34;, name, age) } 3. bufio.Reader bufio.Reader 提供了底层的输入控制，适合需要精确控制输入的场景。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func main() { reader := bufio.NewReader(os.Stdin) // 读取一行（包含换行符） fmt.Print(\u0026#34;请输入姓名: \u0026#34;) name, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) name = strings.TrimSpace(name) // 读取单个字符 fmt.Print(\u0026#34;请输入性别 (M/F): \u0026#34;) gender, _ := reader.ReadByte() fmt.Printf(\u0026#34;姓名: %s, 性别: %c\\n\u0026#34;, name, gender) } 4. io.ReadAll io.ReadAll 用于一次性读取所有输入，适合处理完整的输入流。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 读取所有输入直到 EOF input, _ := io.ReadAll(os.Stdin) fmt.Printf(\u0026#34;输入内容:\\n%s\u0026#34;, input) } 使用建议 简单输入\n使用 fmt.Scan 系列函数 适合基本的用户输入 多行输入\n使用 bufio.Scanner 适合处理文本文件或复杂输入 精确控制\n使用 bufio.Reader 适合需要特殊输入处理的场景 完整输入流\n使用 io.ReadAll 适合处理管道或重定向输入 参考资源 Go fmt 包文档 Go bufio 包文档 Go io 包文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/go-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5%E5%A4%84%E7%90%86/","title":"Go 控制台输入处理"},{"content":"命令行参数简介 在 Go 中，可以通过 os.Args 获取命令行参数。os.Args 是一个字符串切片，其中：\nos.Args[0] 是程序名称 os.Args[1:] 包含所有命令行参数 基本用法 获取所有参数 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 遍历所有参数 for i, arg := range os.Args { fmt.Printf(\u0026#34;参数 %d: %s\\n\u0026#34;, i, arg) } } 运行示例 1 2 3 4 5 6 7 8 # 运行程序 go run main.go arg1 arg2 arg3 # 输出结果 参数 0: /tmp/go-build123456789/b001/exe/main 参数 1: arg1 参数 2: arg2 参数 3: arg3 参数处理 参数解析示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { // 检查参数数量 if len(os.Args) \u0026lt; 2 { fmt.Println(\u0026#34;请提供至少一个参数\u0026#34;) os.Exit(1) } // 处理不同类型的参数 for i := 1; i \u0026lt; len(os.Args); i++ { arg := os.Args[i] // 尝试转换为整数 if num, err := strconv.Atoi(arg); err == nil { fmt.Printf(\u0026#34;数字参数: %d\\n\u0026#34;, num) } else { fmt.Printf(\u0026#34;字符串参数: %s\\n\u0026#34;, arg) } } } 参数验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func main() { // 参数验证示例 if len(os.Args) != 3 { fmt.Println(\u0026#34;用法: program \u0026lt;命令\u0026gt; \u0026lt;参数\u0026gt;\u0026#34;) os.Exit(1) } command := os.Args[1] value := os.Args[2] // 命令验证 switch command { case \u0026#34;add\u0026#34;: fmt.Printf(\u0026#34;添加: %s\\n\u0026#34;, value) case \u0026#34;remove\u0026#34;: fmt.Printf(\u0026#34;删除: %s\\n\u0026#34;, value) default: fmt.Printf(\u0026#34;未知命令: %s\\n\u0026#34;, command) os.Exit(1) } // 参数验证 if strings.TrimSpace(value) == \u0026#34;\u0026#34; { fmt.Println(\u0026#34;参数不能为空\u0026#34;) os.Exit(1) } } 参考资源 Go os 包文档 Go 命令行参数处理 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/go-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/","title":"Go 命令行参数处理"},{"content":"运行 Go 文件 使用 go run 命令可以直接运行 Go 源文件，无需手动编译。这个命令会临时编译并运行指定的文件。\n1 2 3 4 5 6 7 8 # 运行单个文件 go run hello.go # 运行多个文件 go run main.go utils.go # 运行当前目录下的所有 Go 文件 go run . 编译 Go 文件 使用 go build 命令可以编译 Go 源文件，生成可执行文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 编译单个文件 go build hello.go # 编译整个项目 go build # 指定输出文件名 go build -o myapp hello.go # 跨平台编译 # Windows GOOS=windows GOARCH=amd64 go build -o app.exe # Linux GOOS=linux GOARCH=amd64 go build -o app # macOS GOOS=darwin GOARCH=amd64 go build -o app 编译选项 -o：指定输出文件名 -v：显示编译的包名 -x：显示编译命令 -race：启用竞态检测 -ldflags：设置链接参数 运行编译后的程序 编译完成后，可以直接运行生成的可执行文件：\n1 2 3 4 5 # Windows hello.exe # Linux/macOS ./hello 参考资源 Go 命令行文档 Go 构建文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/go-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C%E5%92%8C%E7%BC%96%E8%AF%91/","title":"Go 命令行运行和编译"},{"content":"概述 微信小游戏试玩是一种特殊的游戏体验方式，允许用户在正式下载游戏之前先体验游戏内容。本文将介绍两种在 Cocos Creator 中导出微信小游戏试玩的方法，以及可能遇到的问题和解决方案。\n导出方式 1. 传统方式（使用 adapter） 前置准备 下载官方 demo 工程：wechat-miniprogram/minigame-playable 准备试玩小程序的 AppID 构建步骤 准备构建模板\n将 build-templates 文件夹复制到试玩工程目录下 配置小程序信息\n在项目设置中配置试玩小程序的 AppID 构建小程序\n在 Cocos Creator 中选择\u0026quot;构建微信小游戏\u0026quot; 确保选择正确的构建模板 整合到主游戏\n将构建的小程序工程复制到主游戏的 playableDemo 文件夹下 配置分包信息\n修改主工程的 game.json，添加试玩分包配置： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026#34;subPackages\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;moduleA\u0026#34;, \u0026#34;root\u0026#34;: \u0026#34;/moduleA/\u0026#34; // 普通分包 }, { \u0026#34;independent\u0026#34;: true, \u0026#34;name\u0026#34;: \u0026#34;playableDemo\u0026#34;, \u0026#34;root\u0026#34;: \u0026#34;/playableDemo/\u0026#34;, \u0026#34;meta\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;playable\u0026#34;, \u0026#34;playableOrientation\u0026#34;: \u0026#34;portrait\u0026#34; } } ] 构建分包\n新建分包构建配置 选择\u0026quot;分包构建\u0026quot;模式 执行构建 常见问题 资源文件缺失\n问题：编译时提示 logo.png 和 slogan.png 缺失 解决：复制或创建所需的图片资源文件 引擎裁剪问题\n问题：TypeError: Cannot read property 'passes' of undefined 解决：在 Cocos Creator 中修改引擎裁剪设置 打开 Project Settings 选择 Feature Cropping 在 2D 选项中勾选： User Interface Tiled Map 音频加载失败\n问题：cc.js:88919 failed to load innerAudioContext 解决：由于 adapter 方式的限制，建议使用新的构建方式 2. 新构建方式（推荐） 构建步骤 配置小程序信息\n在项目设置中配置试玩小程序的 AppID 构建微信小游戏\n选择\u0026quot;构建微信小游戏\u0026quot; 使用默认构建配置 导入开发工具\n在微信开发者工具中导入构建结果 工具会自动识别为试玩版本 编译上传\n执行编译 上传到微信平台 优势 构建流程更简单 更好的兼容性 更少的配置步骤 更稳定的运行效果 注意事项 资源限制\n注意试玩包大小限制 合理规划资源加载 避免资源浪费 功能限制\n了解试玩版本的功能限制 避免使用不支持的特性 做好功能降级处理 兼容性\n测试不同设备 验证各种场景 处理异常情况 参考资源 微信小游戏试玩文档 Cocos Creator 文档 微信小游戏开发文档 ","date":"2025-03-06T10:41:48+08:00","permalink":"https://imhy.top/p/cocos-creator-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E8%AF%95%E7%8E%A9%E5%AF%BC%E5%87%BA%E6%8C%87%E5%8D%97/","title":"Cocos Creator 微信小游戏试玩导出指南"},{"content":"开发环境 Unity 2022.3.46f1 Rider 2024.3.33 .NET 6.0.201 Obfuscar 2.2.40 问题背景 为了防代码泄露，需要隔离开发工程和美术工程，将开发工程代码编译成 DLL，并且混淆后导入美术工程使用。\n遇到了一个错误：混淆后的 DLL 在 Unity 中报错 Unable to resolve reference 'System.Private.CoreLib'，而未混淆的 DLL 没有这个问题。\n问题现象 正常情况\n未混淆的 Dave.CodeGen.dll 在 Unity 中正常运行 使用 ILSpy 检查发现引用的是 mscorlib 异常情况\n使用 Obfuscar.Console 混淆后，Unity 报错： 1 Unable to resolve reference \u0026#39;System.Private.CoreLib\u0026#39;. Is the assembly missing or incompatible with the current platform 使用 ILSpy 检查发现引用了 System.Private.CoreLib 问题分析 1. 初步猜测 System.Private.CoreLib 是 .NET Core / .NET 5+ 的核心库 Unity 使用的是 .NET Framework 4.8（基于 mscorlib） 混淆过程可能引入了不兼容的引用 2. 排查过程 检查 .NET 版本 操作步骤\n使用 ILSpy 打开混淆后的 Dave.CodeGen.dll 发现\n目标框架是 .NET Framework 4.7.2，与预期一致 引用中出现了 System.Private.CoreLib 结论\n.NET 版本正确，问题不在目标框架 对比未混淆的 DLL 操作步骤\n用 ILSpy 打开未混淆的 Dave.CodeGen.dll 发现\n未混淆的 DLL 引用的是 mscorlib 没有 System.Private.CoreLib 引用 结论\n混淆过程引入了 System.Private.CoreLib 的引用 环境检查 .NET 环境\n1 2 3 4 5 6 # 检查 SDK 版本 dotnet --list-sdks dotnet --version # 检查运行时版本 dotnet --info Unity 编译\nUnity 自动编译 Unity 命令行编译 输出位置：Library/ScriptAssemblies/ Obfuscar 工具\n1 2 3 4 5 # 安装 dotnet tool install --global Obfuscar.GlobalTool --version 2.2.40 # 卸载 dotnet tool uninstall --global Obfuscar.GlobalTool 解决方案 1. 调整混淆配置 在 Obfuscar 配置文件中添加 mscorlib.dll 的路径（./obfuscar_dependencies/mscorlib.dll）：\n1 \u0026lt;AssemblySearchPath path=\u0026#34;./obfuscar_dependencies\u0026#34; /\u0026gt; 2. 配置步骤 创建依赖目录\n在项目目录下创建 obfuscar_dependencies 文件夹 将 mscorlib.dll 复制到该目录 验证配置\n混淆后的 DLL 引用 mscorlib 无 System.Private.CoreLib 引用 在 Unity 中运行正常 问题根源 原因分析 Obfuscar 在混淆时未找到 mscorlib.dll，可能从系统路径（.NET 6 SDK）加载了 System.Private.CoreLib。这是因为：\nObfuscar 默认会搜索系统路径 系统中安装了 .NET 6 SDK 没有明确指定 mscorlib.dll 的路径 ","date":"2025-03-05T16:03:30+08:00","permalink":"https://imhy.top/p/unity-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84-system.private.corelib-%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/","title":"Unity 项目中的 System.Private.CoreLib 引用问题"},{"content":"基础数据类型 TypeScript 支持 JavaScript 的所有基础数据类型，并添加了类型注解。以下是主要的基础数据类型：\n1. number 类型 表示数字类型，包括整数和浮点数：\n1 2 3 4 5 6 let decimal: number = 6; // 十进制 let hex: number = 0xf00d; // 十六进制 let binary: number = 0b1010; // 二进制 let octal: number = 0o744; // 八进制 let float: number = 3.14; // 浮点数 let scientific: number = 3.14e2; // 科学计数法 2. bigint 类型 表示大整数，可以安全地存储和操作大整数：\n1 2 3 4 5 6 let bigInt: bigint = 9007199254740991n; let bigInt2: bigint = BigInt(9007199254740991); // 注意：bigint 不能与 number 直接运算 let result: bigint = bigInt + 1n; // 正确 let error: bigint = bigInt + 1; // 错误 3. string 类型 表示字符串，支持单引号、双引号和模板字符串：\n1 2 3 4 5 6 7 let name: string = \u0026#34;TypeScript\u0026#34;; let message: string = \u0026#39;Hello World\u0026#39;; let template: string = `Hello ${name}`; let multiline: string = ` This is a multiline string `; 4. boolean 类型 表示布尔值，只有 true 和 false 两个值：\n1 2 let isDone: boolean = false; let isActive: boolean = true; 5. symbol 类型 表示唯一的标识符，通常用于对象属性的键：\n1 2 3 4 5 let sym1: symbol = Symbol(); let sym2: symbol = Symbol(\u0026#34;key\u0026#34;); // 可选的字符串键 // 注意：每个 Symbol 都是唯一的 console.log(sym1 === sym2); // false 6. null 和 undefined 类型 表示空值：\n1 2 3 4 5 6 let u: undefined = undefined; let n: null = null; // 注意：null 和 undefined 是所有类型的子类型 let num: number = undefined; // 正确 let str: string = null; // 正确 7. void 类型 表示没有任何类型，通常用于函数返回值：\n1 2 3 4 5 6 function warnUser(): void { console.log(\u0026#34;This is a warning message\u0026#34;); } // 注意：声明 void 类型的变量只能赋值 undefined 或 null let unusable: void = undefined; 8. object 类型 表示非原始类型，即除 number、string、boolean、symbol、null 或 undefined 之外的类型：\n1 2 3 4 5 6 let obj: object = { name: \u0026#34;TypeScript\u0026#34; }; let arr: object = [1, 2, 3]; let func: object = function() {}; // 注意：object 类型不包含原始类型 let primitive: object = 42; // 错误 类型推断 TypeScript 可以根据上下文自动推断类型：\n1 2 3 4 5 6 7 8 9 10 11 // 类型推断为 number let x = 3; // 类型推断为 string let y = \u0026#34;hello\u0026#34;; // 类型推断为 boolean let z = true; // 类型推断为 number[] let numbers = [1, 2, 3]; 类型注解 可以显式声明变量类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 基本类型注解 let name: string = \u0026#34;TypeScript\u0026#34;; let age: number = 25; let isStudent: boolean = true; // 数组类型注解 let numbers: number[] = [1, 2, 3]; let strings: string[] = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; // 元组类型注解 let tuple: [string, number] = [\u0026#34;hello\u0026#34;, 10]; // 枚举类型注解 enum Color { Red, Green, Blue } let favoriteColor: Color = Color.Blue; 类型断言 允许你覆盖 TypeScript 的类型推断：\n1 2 3 4 5 6 7 // 尖括号语法 let someValue: any = \u0026#34;this is a string\u0026#34;; let strLength: number = (\u0026lt;string\u0026gt;someValue).length; // as 语法 let someValue2: any = \u0026#34;this is a string\u0026#34;; let strLength2: number = (someValue2 as string).length; 最佳实践 优先使用类型推断\n让 TypeScript 自动推断类型 只在必要时添加类型注解 避免使用 any\n优先使用具体的类型 如果必须使用，添加注释说明原因 合理使用类型断言\n只在确信类型正确时使用 优先使用 as 语法而不是尖括号 注意 null 和 undefined\n使用可选链操作符 ?. 使用空值合并操作符 ?? 总结 类型 描述 示例 注意事项 number 数字类型 let num: number = 42 支持整数和浮点数 bigint 大整数 let big: bigint = 9007199254740991n 不能与 number 直接运算 string 字符串 let str: string = \u0026quot;hello\u0026quot; 支持模板字符串 boolean 布尔值 let bool: boolean = true 只有 true/false symbol 唯一标识符 let sym: symbol = Symbol() 每个值都是唯一的 null 空值 let n: null = null 所有类型的子类型 undefined 未定义 let u: undefined = undefined 所有类型的子类型 void 无类型 function f(): void {} 只能赋值 undefined object 非原始类型 let obj: object = {} 不包含原始类型 记住：\n优先使用类型推断 只在必要时添加类型注解 避免使用 any 类型 合理使用类型断言 ","date":"2024-08-23T14:17:35+08:00","permalink":"https://imhy.top/p/typescript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/","title":"TypeScript 数据类型详解"},{"content":"概述 在 Unity 开发微信小游戏时，打开游戏圈和获取用户信息是两个常用的功能。本文将详细介绍这两个功能的实现方法，以及在开发过程中可能遇到的问题和解决方案。\n打开游戏圈 基本实现 创建打开游戏圈的按钮，点击后跳转到微信游戏圈：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var btn = WXBase.CreateGameClubButton(new WXCreateGameClubButtonParam() { type = GameClubButtonType.image, icon = GameClubButtonIcon.light, openlink = url, style = new GameClubButtonStyle() { left = left, top = top, width = w, height = h } }); 按钮样式说明 type：按钮类型 image：图片按钮 text：文字按钮 icon：按钮图标 light：浅色图标 dark：深色图标 style：按钮样式 left：左边距 top：上边距 width：宽度 height：高度 获取用户信息 1. 检查授权状态 在获取用户信息之前，需要先检查用户是否已授权：\n1 2 3 4 5 6 7 8 9 10 WX.GetSetting(new GetSettingOption() { success = (res) =\u0026gt; { var isAuth = res != null \u0026amp;\u0026amp; res.authSetting.ContainsKey(\u0026#34;scope.userInfo\u0026#34;) \u0026amp;\u0026amp; res.authSetting[\u0026#34;scope.userInfo\u0026#34;]; callback.Invoke(isAuth); } }); 2. 获取用户信息 如果用户已授权，可以直接获取用户信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 WX.GetUserInfo(new GetUserInfoOption() { success = (res) =\u0026gt; { if (res == null || res.userInfo == null) { callback.Invoke(null, null); return; } var name = res.userInfo.nickName; var avatar = res.userInfo.avatarUrl; callback.Invoke(name, avatar); }, fail = (res) =\u0026gt; { callback.Invoke(null, null); } }); 3. 创建授权按钮 如果用户未授权，需要创建授权按钮：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var btn = WXBase.CreateUserInfoButton(left, top, w, h, \u0026#34;zh_CN\u0026#34;, false); btn.OnTap((res) =\u0026gt; { // 拒绝授权 if (res.errCode != 0) { callback.Invoke(null, null); return; } callback.Invoke(res.userInfo.nickName, res.userInfo.avatarUrl); btn.Hide(); }); 调试技巧 在微信开发者工具中，可以通过鼠标指针变化来识别授权按钮的位置：\n当鼠标移动到授权按钮区域时，指针会从圈变成箭头 这个特性可以帮助开发者准确定位按钮位置 分辨率问题 分辨率类型 物理分辨率\n设备实际的像素点数 例如：iPhone 14 Pro Max 为 1290*2796 通过 Screen.width 和 Screen.height 获取 逻辑分辨率\n用于界面适配的抽象概念 例如：iPhone 14 Pro Max 为 430*932 通过 GetSystemInfoOption 获取 按钮位置计算 不同按钮使用不同的分辨率系统：\n游戏圈按钮\n使用逻辑分辨率 获取方式： 1 2 3 4 5 6 7 8 9 WX.GetSystemInfo(new GetSystemInfoOption() { success = (info) =\u0026gt; { var dpr = info.pixelRatio; var width = info.screenWidth; var height = info.screenHeight; } }); 授权按钮\n使用物理分辨率 获取方式： 1 2 var width = Screen.width; var height = Screen.height; 分辨率转换 DPR（Device Pixel Ratio）= 物理分辨率 / 逻辑分辨率 例如：iPhone 14 Pro Max 的 DPR = 3 常见问题 按钮位置不准确\n检查是否使用了正确的分辨率系统 验证坐标计算是否正确 考虑设备适配问题 授权失败\n检查网络连接 验证用户是否拒绝授权 确认微信版本是否支持 按钮显示异常\n检查按钮样式设置 验证按钮大小是否合适 确认按钮层级是否正确 参考资源 微信小游戏开发文档 微信小游戏用户信息接口 微信小游戏游戏圈接口 ","date":"2024-08-23T09:59:22+08:00","permalink":"https://imhy.top/p/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%89%93%E5%BC%80%E6%B8%B8%E6%88%8F%E5%9C%88%E5%92%8C%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/","title":"微信小游戏：打开游戏圈和获取用户信息"},{"content":"类型系统概述 在 TypeScript 的类型系统中，any、unknown 和 never 是三个特殊的类型，它们各自具有独特的特性和使用场景。从集合论的角度来看：\nany 和 unknown 是顶层类型（top type），可以包含所有其他类型 never 是底层类型（bottom type），不包含任何值 any 类型 基本特性 any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。从集合论的角度看，any 类型是所有其他类型的全集。\n1 2 3 4 5 6 7 let x: any; x = 1; // 正确 x = \u0026#34;hello\u0026#34;; // 正确 x = false; // 正确 x = []; // 正确 x = {}; // 正确 类型检查关闭 当变量类型设为 any 时，TypeScript 会关闭该变量的类型检查：\n1 2 3 4 5 let x: any = \u0026#39;hello\u0026#39;; x(1) // 不报错 x.foo = 100; // 不报错 x.bar(); // 不报错 类型污染 any 类型存在污染问题，可以赋值给其他任何类型：\n1 2 3 4 5 6 let x: any = \u0026#39;hello\u0026#39;; let y: number; y = x; // 不报错 y * 123; // 不报错 y.toFixed(); // 不报错 使用场景 特殊情况下关闭类型检查\n1 2 // 处理第三方库的类型问题 const thirdPartyLib: any = require(\u0026#39;some-library\u0026#39;); JavaScript 项目迁移\n1 2 // 迁移旧项目时临时使用 const legacyData: any = getLegacyData(); 动态数据处理\n1 2 // 处理动态 API 响应 const response: any = await fetchData(); unknown 类型 基本特性 unknown 是 TypeScript 3.0 引入的类型，可以视为严格版的 any。它表示类型不确定，可能是任意类型，但使用上有严格限制。\n1 2 3 4 5 let x: unknown; x = true; // 正确 x = 42; // 正确 x = \u0026#39;Hello\u0026#39;; // 正确 使用限制 不能赋值给其他类型\n1 2 3 4 5 let v: unknown = 123; let v1: boolean = v; // 报错 let v2: number = v; // 报错 let v3: string = v; // 报错 不能直接访问属性和方法\n1 2 3 4 5 6 7 8 let v1: unknown = { foo: 123 }; v1.foo; // 报错 let v2: unknown = \u0026#39;hello\u0026#39;; v2.trim(); // 报错 let v3: unknown = (n = 0) =\u0026gt; n + 1; v3(); // 报错 允许的操作 unknown 类型变量只能进行以下操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let a: unknown = 1; // 允许的操作 a === 1; // 比较运算 a !== 1; // 比较运算 !a; // 取反运算 a \u0026amp;\u0026amp; b; // 逻辑运算 a || b; // 逻辑运算 a ? b : c; // 条件运算 typeof a; // typeof 运算符 a instanceof Date; // instanceof 运算符 // 不允许的操作 a + 1; // 报错 a.toString(); // 报错 类型收窄 使用类型收窄后，可以安全地使用 unknown 类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 function processValue(value: unknown) { if (typeof value === \u0026#39;string\u0026#39;) { console.log(value.toUpperCase()); // 正确 } if (value instanceof Date) { console.log(value.getTime()); // 正确 } if (Array.isArray(value)) { console.log(value.length); // 正确 } } never 类型 基本特性 never 类型表示永远不会发生的类型，不包含任何值。从集合论的角度看，它是空集。\n1 2 let x: never; // 正确 let a: never = 1; // 报错 使用场景 永不返回的函数\n1 2 3 function throwError(): never { throw new Error(\u0026#39;Error\u0026#39;); } 穷尽性检查\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Shape = \u0026#39;circle\u0026#39; | \u0026#39;square\u0026#39;; function getArea(shape: Shape): number { switch (shape) { case \u0026#39;circle\u0026#39;: return Math.PI * radius * radius; case \u0026#39;square\u0026#39;: return side * side; default: const _exhaustiveCheck: never = shape; return _exhaustiveCheck; } } 类型收窄\n1 2 3 4 5 6 7 8 9 function processValue(value: string | number) { if (typeof value === \u0026#39;string\u0026#39;) { // value 被收窄为 string 类型 } else if (typeof value === \u0026#39;number\u0026#39;) { // value 被收窄为 number 类型 } else { // value 被收窄为 never 类型 } } 最佳实践 避免使用 any\n优先使用具体的类型 如果必须使用，添加 // @ts-ignore 注释说明原因 使用 unknown 替代 any\n处理外部数据时使用 unknown 通过类型收窄安全地使用 合理使用 never\n用于表示不可能的情况 帮助 TypeScript 进行穷尽性检查 总结 类型 描述 特点 使用场景 any 任意类型 关闭类型检查，可污染其他类型 旧项目迁移，第三方库集成 unknown 未知类型 类型安全，需要类型收窄 处理外部数据，API 响应 never 空类型 不包含任何值 穷尽性检查，永不返回的函数 记住：\nany 和 unknown 是顶层类型，可以承接任何类型 never 是底层类型，可以赋值给任何类型 优先使用 unknown 而不是 any 使用 never 进行穷尽性检查 ","date":"2024-08-21T15:27:36+08:00","permalink":"https://imhy.top/p/typescript-%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8Banyunknown-%E5%92%8C-never/","title":"TypeScript 特殊类型：any、unknown 和 never"},{"content":"Git 基础配置 1. 全局配置 1 2 3 4 5 6 7 8 9 10 11 12 # 配置用户信息 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;your.email@example.com\u0026#34; # 配置默认编辑器 git config --global core.editor \u0026#34;code --wait\u0026#34; # 配置默认分支名 git config --global init.defaultBranch main # 配置中文显示 git config --global core.quotepath false 2. 常用别名配置 1 2 3 4 5 6 # 配置常用命令别名 git config --global alias.st status git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; Git 新特性 Git 2.23 及以后版本 版本 新特性 说明 2.23 git switch 简化分支切换操作，替代部分 git checkout 功能 2.23 git restore 恢复文件状态的新命令，替代部分 git checkout 和 git reset 功能 2.24 git sparse-checkout 允许只检出仓库部分内容，节省空间 2.25 git switch/restore 增强 改进功能和稳定性 2.26 git restore --source 允许指定恢复内容的源 2.27 git commit --verbose 提交时显示详细变更信息 2.28 git config includeIf 支持条件性包含配置文件 2.29 git diff --inter-hunk-context 增强 diff 上下文显示 2.30 git commit --no-verify 跳过钩子验证的提交选项 2.31 git switch --orphan 创建新的孤立分支 2.32 git commit --dry-run 预查看提交内容 2.33 git branch --show-current 显示当前分支的简化命令 2.34 git rebase --exec 在变基操作后执行指定命令 常用操作 1. 仓库初始化 1 2 3 4 5 6 7 8 9 10 11 # 初始化新仓库 git init # 克隆远程仓库 git clone \u0026lt;repository_url\u0026gt; # 克隆特定分支 git clone -b \u0026lt;branch_name\u0026gt; \u0026lt;repository_url\u0026gt; # 浅克隆（只获取最新版本） git clone --depth 1 \u0026lt;repository_url\u0026gt; 2. 分支操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 创建并切换分支 git switch -c \u0026lt;branch_name\u0026gt; # 切换分支 git switch \u0026lt;branch_name\u0026gt; # 查看分支 git branch # 删除分支 git branch -d \u0026lt;branch_name\u0026gt; # 强制删除分支 git branch -D \u0026lt;branch_name\u0026gt; 3. 提交操作 1 2 3 4 5 6 7 8 9 10 11 # 暂存文件 git add \u0026lt;file_name\u0026gt; # 暂存所有更改 git add . # 提交更改 git commit -m \u0026#34;commit message\u0026#34; # 修改最后一次提交 git commit --amend 4. 远程操作 1 2 3 4 5 6 7 8 9 10 11 # 添加远程仓库 git remote add \u0026lt;remote_name\u0026gt; \u0026lt;repository_url\u0026gt; # 推送到远程 git push \u0026lt;remote_name\u0026gt; \u0026lt;branch_name\u0026gt; # 拉取更新 git pull \u0026lt;remote_name\u0026gt; \u0026lt;branch_name\u0026gt; # 强制推送（谨慎使用） git push -f \u0026lt;remote_name\u0026gt; \u0026lt;branch_name\u0026gt; 高级操作 1. 覆盖所有提交 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 创建孤立分支 git checkout --orphan temp_branch # 添加所有文件 git add . # 提交更改 git commit -m \u0026#34;init\u0026#34; # 删除主分支 git branch -D main # 重命名分支 git branch -m temp_branch main # 强制推送到远程 git push -f origin main 注意：此操作不可撤销，请谨慎使用！\n2. 交互式变基 1 2 3 4 5 6 7 8 9 10 # 开始交互式变基 git rebase -i HEAD~3 # 修改最近3次提交 # 常用变基命令 # p, pick = 使用提交 # r, reword = 使用提交，但修改提交信息 # e, edit = 使用提交，但停止修改 # s, squash = 使用提交，但合并到前一个提交 # f, fixup = 类似 squash，但丢弃提交信息 # d, drop = 删除提交 3. 暂存操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 暂存当前更改 git stash # 暂存并添加描述 git stash push -m \u0026#34;stash message\u0026#34; # 查看暂存列表 git stash list # 应用暂存 git stash pop # 应用并删除 git stash apply # 应用但保留 # 删除暂存 git stash drop \u0026lt;stash_id\u0026gt; 常见问题 1. 中文显示问题 1 2 # 解决中文文件名显示问题 git config --global core.quotepath false 2. 大文件处理 1 2 3 4 # 使用 Git LFS 管理大文件 git lfs install git lfs track \u0026#34;*.psd\u0026#34; git lfs track \u0026#34;*.zip\u0026#34; 3. 凭证管理 1 2 3 # 配置凭证缓存 git config --global credential.helper cache git config --global credential.helper \u0026#39;cache --timeout=3600\u0026#39; 最佳实践 提交规范\n使用清晰的提交信息 遵循约定式提交规范 保持提交粒度适中 分支管理\n使用功能分支开发 定期合并主分支 及时删除无用分支 代码审查\n提交前自测 使用 Pull Request 进行代码审查 安全实践\n定期备份仓库 谨慎使用强制推送 保护敏感信息 ","date":"2024-08-20T16:39:37+08:00","permalink":"https://imhy.top/p/git-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Git 使用指南"},{"content":"简介 GoldenDict 是一款功能强大的开源词典软件，支持多种词典格式，可以集成在线翻译服务，是学习和工作中不可或缺的翻译工具。\n主要特点：\n支持多种词典格式（StarDict、Babylon、Lingvo 等） 可集成在线翻译服务（Google、DeepL 等） 支持全文搜索 跨平台支持（Windows、Linux、macOS） 可定制的界面和快捷键 安装 使用 Scoop 安装 1 2 # 安装 GoldenDict scoop install goldendict 便携模式说明 Scoop 安装的 GoldenDict 默认启用便携模式（Portable Mode），这意味着：\n配置目录\n在程序目录下会自动创建 portable 文件夹 所有配置文件都存储在这个文件夹中 路径通常为：%SCOOP%/apps/goldendict/current/portable 词典目录限制\n便携模式下只能识别 content 文件夹中的词典 无法通过界面添加其他目录的词典 路径为：%SCOOP%/apps/goldendict/current/content 解决方案\n将词典文件复制到 content 文件夹中\n或者创建符号链接指向其他词典目录：\n1 2 # 以管理员身份运行 mklink /D \u0026#34;%SCOOP%\\apps\\goldendict\\current\\content\\词典名称\u0026#34; \u0026#34;实际词典目录路径\u0026#34; 手动安装 访问 GoldenDict 官网 或 GitHub 发布页 下载最新版本安装包 运行安装程序 词典推荐 词典下载 推荐网站：词典网站\n将词典文件放到 %SCOOP%/apps/goldendict/current/content 路径\n1. 英语词典 离线词典\n朗文当代英语词典（Longman）：英英释义详尽，例句地道 牛津高阶英汉双解词典（Oxford）：权威性强，释义准确 柯林斯高阶英汉双解词典（Collins）：例句丰富，搭配详细 剑桥高阶英汉双解词典（Cambridge）：英美发音齐全 韦氏高阶英汉双解词典（Merriam-Webster）：美式英语为主 Vocabulary.com Dictionary：词源解释详细，助记功能强 IT 专业词典\n计算机英语词典：收录专业术语 信息技术词典：包含最新 IT 领域词汇 编程语言词典：各种编程语言的专业术语 GitHub Glossary：开源社区常用术语 2. 词典格式说明 GoldenDict 支持以下主流词典格式：\nBabylon (BGL)\n文件扩展名：.bgl 特点：压缩率高，加载速度快 StarDict\n文件扩展名：.ifo, .dict, .idx 特点：开源格式，兼容性好 Lingvo (DSL)\n文件扩展名：.dsl, .dsl.dz 特点：支持复杂格式，显示效果好 MDict\n文件扩展名：.mdx, .mdd 特点：广泛使用，资源丰富 3. 词典下载地址 开源词典\nECDICT：英汉词典数据库 FreeDictionaryProject：自由词典项目 专业词典\nIT-Dictionary：IT 专业词典 MDX/MDD 词典下载：胡正维护的词典下载站 在线翻译配置 1. Google 翻译 安装翻译工具\n1 2 3 4 5 # 安装 Python（如果未安装） scoop install python # 安装 Google 翻译工具 pip3 install google-translate-for-goldendict 配置 GoldenDict\n编辑 \u0026gt; 词典 \u0026gt; 词典来源 \u0026gt; 程式 点击 添加 设置以下参数： 类型：Html 名称：Google Translate 命令行：python -m googletranslate zh-CN %GDWORD% 图示：可选，下载 google_translate.png 使用技巧 快速切换词典\n使用 Tab 键在结果中切换 使用数字键快速选择词典组 自定义样式\n使用自定义 CSS 美化界面 调整字体和颜色 优化显示布局 批量查询\n使用文本文件导入 导出查询历史 生成生词本 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/goldendict-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"GoldenDict 使用指南"},{"content":"Hugo 安装和简单使用请查看上篇文档\n主题特色 Stack 主题具有以下特色功能：\n现代化设计\n响应式布局，完美支持移动端 暗色/亮色主题切换 优雅的卡片式设计 丰富功能\n文章目录自动生成 阅读时间估算 文章字数统计 代码高亮 表情支持 图片画廊 社交集成\n社交媒体链接 文章分享功能 GitHub 编辑链接 性能优化\n延迟加载图片 代码块复制 平滑滚动 多语言支持\n内置中文支持 可扩展其他语言 安装配置 添加 Stack 主题 在个人站点目录，执行如下命令以 git 子模块的模式来添加 Stack：\n1 2 3 4 5 6 7 8 # 添加主题 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 更新主题 git submodule update --remote # 查看主题版本号 git show 拉取完毕后，打开博客文件夹内的 theme/hugo-theme-stack/exampleSite，将文件夹内的 hugo.yaml 复制到站点根目录下，同时删除原有的 hugo.toml。\n为了打造更符合自己心意的站点，需要将主题的资源复制到个人站点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # Windows 系统使用以下命令 xcopy themes\\hugo-theme-stack\\archetypes archetypes\\ /E /I xcopy themes\\hugo-theme-stack\\assets assets\\ /E /I xcopy themes\\hugo-theme-stack\\data data\\ /E /I xcopy themes\\hugo-theme-stack\\i18n i18n\\ /E /I xcopy themes\\hugo-theme-stack\\layouts layouts\\ /E /I # Linux/macOS 系统使用以下命令 cp -r themes/hugo-theme-stack/archetypes/* archetypes/ cp -r themes/hugo-theme-stack/assets/* assets/ cp -r themes/hugo-theme-stack/data/* data/ cp -r themes/hugo-theme-stack/i18n/* i18n/ cp -r themes/hugo-theme-stack/layouts/* layouts/ 配置说明 hugo.yaml 主要配置项说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 # 基础配置 baseurl: \u0026#34;https://example.com\u0026#34; # 博客的 URL languageCode: \u0026#34;zh-cn\u0026#34; # 语言代码 theme: \u0026#34;hugo-theme-stack\u0026#34; # 主题名称 paginate: 10 # 每页显示的文章数量 title: \u0026#34;我的博客\u0026#34; # 网站名称 copyright: \u0026#34;© 2024\u0026#34; # 网站底部的版权信息 # 语言设置 DefaultContentLanguage: \u0026#34;zh-cn\u0026#34; # 默认显示的语言 hasCJKLanguage: true # 中文字数统计 # 多语言设置 languages: zh-cn: languageName: \u0026#34;简体中文\u0026#34; weight: 1 title: \u0026#34;我的博客\u0026#34; [languageContentDir]: \u0026#34;content/zh-cn\u0026#34; [languageMenuName]: \u0026#34;简体中文\u0026#34; # 服务配置 services: googleAnalytics: \u0026#34;UA-XXXXXXXX-X\u0026#34; # Google 分析代码 disqus: \u0026#34;your-disqus-shortname\u0026#34; # Disqus 评论系统 utterances: \u0026#34;your-repo\u0026#34; # GitHub 评论系统 # 参数配置 params: favicon: \u0026#34;/img/favicon.ico\u0026#34; # 站点图标 footer: since: 2024 # 创建博客的年份 dateFormat: published: \u0026#34;2006-01-02\u0026#34; # 发布时间格式 lastUpdated: \u0026#34;2006-01-02 15:04 MST\u0026#34; # 最后更新时间格式 sidebar: emoji: \u0026#34;🍀\u0026#34; # 头像右下角的 emoji subtitle: \u0026#34;热爱生活\u0026#34; # 头像下方的副标题 avatar: src: \u0026#34;/img/avatar.png\u0026#34; # 头像图片位置 menu: - identifier: \u0026#34;home\u0026#34; name: \u0026#34;首页\u0026#34; url: \u0026#34;/\u0026#34; params: newTab: false - identifier: \u0026#34;about\u0026#34; name: \u0026#34;关于\u0026#34; url: \u0026#34;/about\u0026#34; params: newTab: false # 文章配置 article: math: false # 数学公式支持 toc: true # 目录显示 readingTime: true # 阅读时间 license: enabled: false # 版权信息 default: Licensed under CC BY-NC-SA 4.0 edit: enabled: true # GitHub 编辑 wordCount: true # 字数统计 # 菜单配置 menu: social: - identifier: \u0026#34;github\u0026#34; name: \u0026#34;GitHub\u0026#34; url: \u0026#34;https://github.com/yourusername\u0026#34; params: newTab: true - identifier: \u0026#34;twitter\u0026#34; name: \u0026#34;Twitter\u0026#34; url: \u0026#34;https://twitter.com/yourusername\u0026#34; params: newTab: true 功能使用 使用表情 Stack 主题已开启表情支持，可以在表情仓库查找需要的表情。\n使用示例：\n1 :smile: :heart: :rocket: 使用本地图片 Hugo 会根据内容文件的路径以及 permalinks 配置来生成 URL 和文件夹结构。\n目录结构示例：\n1 2 3 4 5 6 content/ ├── post │ └── blog │ └── images │ └── test.png │ └── first.md 编译后的结构：\n1 2 3 4 5 6 7 8 public/ ├── p │ └── first │ └── index.html └── post └── blog └── images └── test.png 在 first.md 中引用图片：\n1 ![](/post/博客搭建/images/test.png) 个性化设置 自定义小图标 访问 Tabler Icons 搜索想要的图标 设置图标参数： Size: 24px Stroke: 2px 点击图标复制 SVG 代码 在网站根目录的 assets/icons/ 文件夹创建 .svg 文件 在配置中使用图标 文章底部添加 GitHub 编辑链接 复制主题文件： 1 cp themes/hugo-theme-stack/assets/layouts/partials/article/components/footer.html layouts/partials/article/components/ 修改 footer.html： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;footer class=\u0026#34;article-footer\u0026#34;\u0026gt; {{ partial \u0026#34;article/components/tags\u0026#34; . }} {{ if and (.Site.Params.article.license.enabled) (not (eq .Params.license false)) }} \u0026lt;section class=\u0026#34;article-copyright\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;copyright\u0026#34; }} \u0026lt;span\u0026gt;{{ default .Site.Params.article.license.default .Params.license | markdownify }}\u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; {{ end }} \u0026lt;!-- GitHub 编辑链接 --\u0026gt; {{ if and (.Site.Params.article.edit.enabled) (not (eq .Params.edit false)) }} \u0026lt;section class=\u0026#34;article-edit\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;brand-github\u0026#34; }} \u0026lt;span\u0026gt; \u0026lt;a href=\u0026#34;https://github.com/yourusername/yourusername.github.io/edit/main/content/{{ replace .File.Path \u0026#34;\\\\\u0026#34; \u0026#34;/\u0026#34; }}\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34;\u0026gt; 在 GitHub 上编辑此页 \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; {{ end }} {{- if ne .Lastmod .Date -}} \u0026lt;section class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;span\u0026gt; {{ T \u0026#34;article.lastUpdatedOn\u0026#34; }} {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; {{- end -}} \u0026lt;/footer\u0026gt; 在 hugo.yaml 中启用编辑功能： 1 2 3 4 5 6 7 8 9 article: math: false toc: true readingTime: true license: enabled: false default: Licensed under CC BY-NC-SA 4.0 edit: enabled: true # 启用编辑功能 自动更新文章最后修改时间 在 hugo.yaml 中添加以下配置：\n1 2 3 4 5 6 7 8 9 10 frontmatter: # 按优先级排序： # :git - 文件提交修改时间 # lastmod - 文章里 lastmod 字段 # :fileModTime - 文件修改时间 # :default - 默认时间 lastmod: [\u0026#34;:git\u0026#34;, \u0026#34;lastmod\u0026#34;, \u0026#34;:fileModTime\u0026#34;, \u0026#34;:default\u0026#34;] enableGitInfo: true gitRepo: \u0026#34;https://github.com/yourusername/yourusername.github.io\u0026#34; 文章字数统计 修改 layouts/partials/article/components/details.html： 1 2 3 4 5 6 7 8 {{ if .Site.Params.article.wordCount }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;pencil\u0026#34; }} \u0026lt;time class=\u0026#34;article-words\u0026#34;\u0026gt; {{ .WordCount }} 字 \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 在 hugo.yaml 中启用字数统计： 1 2 article: wordCount: true 站点总字数统计 修改 layouts/partials/footer/footer.html： 1 2 3 4 5 6 7 8 9 10 {{$scratch := newScratch}} {{ range (where .Site.Pages \u0026#34;Kind\u0026#34; \u0026#34;page\u0026#34; )}} {{$scratch.Add \u0026#34;total\u0026#34; .WordCount}} {{ end }} \u0026lt;section class=\u0026#34;wordcount\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ div ($scratch.Get \u0026#34;total\u0026#34;) 1000.0 | lang.FormatNumber 2 }}k 字 \u0026lt;br\u0026gt;{{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;post\u0026#34;) }}篇文章 \u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; 修改 assets/scss/partials/footer.scss： 1 2 3 4 .wordcount { color: var(--accent-color); margin-bottom: 5px; } 界面优化 缩小归档页的分类卡片尺寸 修改 assets/scss/partials/layout/list.scss：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 .subsection-list { overflow-x: auto; .article-list--tile { display: flex; padding-bottom: 0px; article { width: 150px; height: 90px; margin-right: 5px; flex-shrink: 0; .article-title { margin: 0; font-size: 1.8rem; } .article-details { padding: 20px; } } } } 在首页文件列表显示内容简介 修改 assets/layouts/partials/article-list/default.html： 1 2 3 4 5 6 7 {{ with .Params.description }} \u0026lt;div class=\u0026#34;article-subtitle-wrapper\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;article-subtitle\u0026#34;\u0026gt; {{ . }} \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 修改 assets/scss/custom.scss： 1 2 3 4 5 6 7 8 9 .article-subtitle-wrapper { padding-left: var(--card-padding); padding-right: var(--card-padding); padding-bottom: var(--card-padding); } .article-time { padding-top: 5px; } 删除 layouts/partials/article/components/details.html 中的 article-subtitle 在归档列表显示内容简介 修改 assets/layouts/partials/article-list/compact.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;article-title\u0026#34;\u0026gt; {{- .Title -}} \u0026lt;/h2\u0026gt; {{ with .Params.description }} \u0026lt;div class=\u0026#34;article-subtitle\u0026#34;\u0026gt; {{ . }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; \u0026lt;time datetime=\u0026#39;{{ .Date.Format \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; }}\u0026#39;\u0026gt; {{- .Date.Format (or .Site.Params.dateFormat.published \u0026#34;Jan 02, 2006\u0026#34;) -}} \u0026lt;/time\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; 代码块样式优化 修改 assets/scss/partials/layout/article.scss：\n1 2 3 4 5 6 7 8 9 10 11 .highlight { margin-left: 0; margin-right: 0; width: calc(100%); border-radius: var(--card-border-radius); } .copyCodeButton { top: 5px; right: 5px; } ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/hugo-stack-%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BE%8E%E5%8C%96%E9%85%8D%E7%BD%AE/","title":"Hugo Stack 主题使用和美化配置"},{"content":"Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\n为什么选择 Hugo？ Hugo 作为静态网站生成器，具有以下优势：\n极快的构建速度：Hugo 是目前最快的静态网站生成器之一 丰富的主题生态：有大量精美的主题可供选择 强大的内容管理：支持 Markdown、HTML、JSON 等多种格式 灵活的模板系统：使用 Go 模板语法，易于定制 活跃的社区：持续更新维护，问题解决快速 完善的文档：官方文档详尽，示例丰富 多平台支持：支持 Windows、macOS、Linux 等主流操作系统 安装 hugo 有两个版本，标准版和扩展版，推荐使用扩展版。\nWindows 安装 使用 scoop 安装\n1 scoop install hugo-extended 注意：*目前scoop版本过低，编译最新stack主题的时候会报错，所以推荐使用下面方法安装。\n下载二进制安装，github地址\na. 下载二进制版本 b. 解压文件 c. 配置环境变量\n打开系统环境变量设置 在 Path 中添加 Hugo 解压目录 验证安装：打开新的命令行窗口，运行 hugo version macOS 安装 使用 Homebrew 安装\n1 brew install hugo 使用二进制安装\n下载 macOS 版本的二进制文件 解压并移动到 /usr/local/bin/ 验证安装：hugo version Linux 安装 使用包管理器安装\nUbuntu/Debian:\n1 sudo apt install hugo CentOS/RHEL:\n1 sudo dnf install hugo 使用二进制安装\n下载 Linux 版本的二进制文件 解压并移动到 /usr/local/bin/ 验证安装：hugo version 验证安装 安装完成后，运行以下命令验证安装：\n1 hugo version 扩展版可以在输出中看到 +extended 标识。\n基本命令 Hugo 提供了丰富的命令行工具，以下是一些常用命令：\n1 2 3 4 5 # 查看所有可用命令 hugo help # 查看具体命令的帮助信息 hugo server --help 新建站点 一个站点对应本地的一个文件夹，如：希望在 /site_path/site_name 路径创建一个站点\n1 hugo new site site_path/site_name 创建成功以后切换到对应路径\n1 cd site_path/site_name 可以看到如下文件结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 site_name/ ├── archetypes/ # 新内容的模板目录 │ └── default.md # 默认文章模板 ├── assets/ # 全局资源目录 │ ├── css/ # CSS 文件 │ ├── js/ # JavaScript 文件 │ └── images/ # 图片资源 ├── content/ # 网站内容目录 │ └── post/ # 文章目录 ├── data/ # 数据文件目录 ├── i18n/ # 多语言翻译目录 ├── layouts/ # 自定义布局模板 ├── static/ # 静态资源目录 ├── themes/ # 主题目录 └── hugo.toml # 站点配置文件 各目录说明：\narchetypes/: 新内容的模板目录，用于定义新文章的基本结构 assets/: 全局资源目录，包含 CSS、JavaScript、图片等资源文件 content/: 网站内容目录，存放所有文章和页面 data/: 数据文件目录，用于存放 JSON、TOML、YAML 或 XML 格式的数据文件 i18n/: 多语言翻译目录，存放不同语言的翻译文件 layouts/: 自定义布局模板目录，用于覆盖主题的默认布局 static/: 静态资源目录，存放不需要处理的静态文件 themes/: 主题目录，存放一个或多个主题 hugo.toml: 站点配置文件，定义网站的基本设置 新建文章 新建的文章会根据 archetypes/default.md 模板创建在 content/ 目录下\n1 hugo new path/test.md 本地调试 在发布文章之前，你可能希望在本地调试，在站点根路径执行 hugo 命令进行调试\n1 2 3 4 5 6 7 # 启动本地服务器 hugo server # --buildDrafts 包含草稿文章 hugo server --buildDrafts # or hugo server -D 在浏览器打开 http://localhost:1313 可查看生成的文章\n生成最终页面 将文章中的 draft 修改为 false\n1 2 3 4 hugo #开始代码压缩 hugo --minify 运行以后将在站点目录生成 public 目录，该目录包含生成的已发布网站。Hugo根据需要重新创建此目录及其内容。查看详细资料\n⚠️Hugo在构建站点前不会清空目录。 根据当前四个条件的评估结果，构建后你的目录可能包含来自以前构建的多余文件。通常的做法是在每次构建之前手动清空目录的内容以删除草稿、过期和未来的内容。\n所以推荐使用代参构建\n1 2 # 这个选项会在 Hugo 构建时清理生成目录中的内容，确保只有最新构建的文件保留 hugo --cleanDestinationDir 部署到 Github Pages 手动部署 首先在 GitHub 上创建一个名为 xxx.github.io 的仓库（xxx 为你的 GitHub 用户名）\n将 public 文件夹关联到刚创建的仓库\n1 2 3 4 5 6 7 cd public git init git remote add origin https://github.com/xxxx/xxxx.github.io.git git branch -M main git add . git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin main 之后可在浏览器访问 http://xxx.github.io 查看发布的文章\n注意：手动部署需要每次修改文章后手动编译并推送到 xxx.github.io 仓库，这种方式比较繁琐\n自动部署 创建两个仓库：\n私有库：存放博客源码（如 MySite） 公开库：xxx.github.io（用于部署） 创建 Personal Access Token (PAT)\nPAT 用于授权私有库访问目标库的权限，使 Actions 可以推送构建好的代码\n打开 GitHub Settings 进入 Developer settings 选择 Personal access tokens 点击 Tokens(classic) 勾选 workflow 和 write:packages 生成并保存 PAT（以 ghp_ 开头） 配置仓库 Secrets\n打开私有库的 Settings 选择 Secrets and variables \u0026gt; Actions 添加新的 Secret，名称为 SECRET_BLOG，值为刚才生成的 PAT 配置 GitHub Actions\n在私有库的 Actions 页面创建新的 workflow 搜索并选择 Hugo 模板 修改配置文件中的以下参数： hugo-version：设置为你的 Hugo 版本（通过 hugo version 查看） personal_token：设置为 ${{ secrets.SECRET_BLOG }} external_repository：设置为 xxx/xxx.github.io 完整的配置文件示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 name: GitHub Pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-22.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v4 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#39;0.132.2\u0026#39; extended: true - name: Build run: hugo --minify --cleanDestinationDir - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: personal_token: ${{ secrets.XXX }} publish_branch: main publish_dir: ./public external_repository: xxx/xxx.github.io cname: imhy.top 配置完成后，每次推送代码到 main 分支时，GitHub Actions 会自动构建并部署到你的个人网站。\n基础使用 文章写作最佳实践 文章结构\n使用清晰的标题层级 添加适当的空行提高可读性 使用列表和表格组织内容 添加代码块时指定语言 Front Matter 配置\n注意：使用主题后，以下配置会自动添加到文章头部，无需手动添加\n1 2 3 4 5 6 7 8 9 10 11 12 13 --- title: \u0026#34;文章标题\u0026#34; description: \u0026#34;文章描述\u0026#34; date: 2024-03-19T12:00:00+08:00 image: /images/cover.jpg categories: - 分类1 - 分类2 tags: - 标签1 - 标签2 draft: false --- 图片管理\n使用相对路径引用图片 图片放在 static/images/ 目录下 使用 Hugo 的图片处理功能优化图片 为图片添加描述性文本，帮助搜索引擎和屏幕阅读器理解图片内容 代码块使用\n基本的 Markdown 代码块语法：\n```python def hello_world(): print(\"Hello, Hugo!\") ``` 命令行示例语法：\n```bash # 命令行示例 hugo new post/my-first-post.md ``` 链接管理\n使用相对路径链接内部文章 使用 [text]({{\u0026lt; relref \u0026ldquo;/post/file.md\u0026rdquo; \u0026gt;}}) 外部链接添加 target=\u0026quot;_blank\u0026quot; 和 rel=\u0026quot;noopener\u0026quot; 性能优化建议 构建优化\n使用 --minify 压缩输出 合理使用 partial 和 shortcode 避免过度使用 JavaScript 使用 Hugo Pipes 处理资源 图片优化\n使用 WebP 格式 实现响应式图片 使用 Hugo 的图片处理功能 合理设置图片尺寸 缓存优化\n配置浏览器缓存 使用 CDN 加速 优化资源加载顺序 主题配置 主题选择建议 选择标准\n活跃度：查看主题的更新频率和 star 数 文档完整性：是否有详细的配置文档 响应式设计：是否支持移动端 功能丰富度：是否满足需求 定制难度：是否易于修改 推荐主题\nStack：现代化设计，功能丰富 PaperMod：简洁优雅，性能优秀 LoveIt：中文友好，功能完善 DoIt：适合技术博客 主题安装 主题使用请查看这篇文章文档\n常见问题 1. 构建失败 问题：执行 hugo 命令时报错 解决方案：\n检查 Hugo 版本是否兼容 检查主题版本是否最新 检查配置文件语法 查看详细错误日志 2. 图片无法显示 问题：本地预览正常，部署后图片无法显示 解决方案：\n检查图片路径是否正确 确保图片文件已提交到仓库 使用相对路径引用图片 检查图片文件名大小写 3. 主题样式丢失 问题：部署后主题样式完全丢失 解决方案：\n检查主题是否正确安装 检查主题版本兼容性 检查主题资源文件是否完整 检查构建命令是否正确 4. 自定义域名无法访问 问题：配置自定义域名后无法访问 解决方案：\n检查 DNS 配置是否正确 等待 DNS 生效 检查 SSL 证书配置 检查 GitHub Pages 设置 5. 评论系统不显示 问题：配置评论系统后不显示 解决方案：\n检查评论系统配置是否正确 检查 API 密钥是否有效 检查评论系统服务是否正常 检查浏览器控制台错误 维护建议 定期更新\n更新 Hugo 到最新版本 更新主题到最新版本 检查依赖包更新 更新评论系统配置 内容备份\n定期备份 content 目录 备份配置文件 备份自定义主题文件 使用 Git 进行版本控制 性能监控\n使用 Google Analytics 监控访问 使用 PageSpeed Insights 检查性能 监控服务器响应时间 检查资源加载情况 安全维护\n定期更新依赖包 检查安全漏洞 更新 SSL 证书 保护敏感信息 相关资源 Hugo 官方文档 Hugo 主题列表 Hugo 论坛 Hugo GitHub ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"Hugo 搭建个人博客"},{"content":"什么是 PowerToys？ PowerToys 是微软开发的一套实用工具集，旨在帮助高级用户调整和简化 Windows 体验以提高工作效率。它包含多个实用工具，如快速启动器、窗口管理、颜色选择器等。\n安装方法 使用 Scoop 安装 1 scoop install powertoys 使用 Winget 安装 1 winget install Microsoft.PowerToys 手动安装 访问 PowerToys GitHub 发布页面 下载最新版本的安装包 运行安装程序 核心功能配置 1. 颜色选择器 (Color Picker) 快捷键：Win + Shift + C 功能：快速获取屏幕任意位置的颜色值 支持格式：HEX、RGB、HSL、CMYK 等 2. PowerToys Run 快捷键：Alt + Space 功能：快速启动应用程序和文件 特点： 支持模糊搜索 可安装插件扩展功能 支持计算器和单位转换 3. File Locksmith 功能：显示正在使用文件的进程 使用方法： 右键点击文件 选择\u0026quot;查看哪些进程正在使用此文件\u0026quot; 查看并管理相关进程 4. FancyZones 功能：增强的窗口管理工具 特点： 自定义窗口布局 支持多显示器 可保存常用布局 插件安装与配置 PowerToys Run Everything 插件 安装插件\n1 scoop install everything-powertoys 配置步骤\n下载 Everything64.dll\n将 DLL 文件复制到 everything-powertoys 安装目录\n将插件复制到 PowerToys 插件目录：\n1 C:\\Users\\\u0026lt;用户名\u0026gt;\\AppData\\Local\\Microsoft\\PowerToys\\PowerToys Run\\Plugins 在 PowerToys Run 设置中：\n启用 Everything 插件 设置 Everything 运行路径 重启 PowerToys\n其他推荐插件 Window Walker\n快速切换窗口 支持模糊搜索 Registry Preview\n预览注册表文件 支持语法高亮 PowerRename\n批量重命名文件 支持正则表达式 快捷键设置 常用快捷键 Win + Shift + C：颜色选择器 Alt + Space：PowerToys Run Win + Shift + D：快速桌面 Win + Shift + T：文本提取器 自定义快捷键 打开 PowerToys 设置 选择\u0026quot;键盘管理器\u0026quot; 点击\u0026quot;添加新的快捷键\u0026quot; 设置快捷键组合和对应功能 性能优化 启动项管理 打开 PowerToys 设置 选择\u0026quot;启动项\u0026quot; 配置开机自启动项 资源占用 建议关闭不常用的功能 定期检查后台进程 根据需要调整功能配置 常见问题 1. 插件无法加载 检查插件安装路径 确认 DLL 文件位置 验证插件兼容性 2. 快捷键冲突 检查系统快捷键设置 调整 PowerToys 快捷键 避免与其他软件冲突 3. 性能问题 关闭不必要的功能 更新到最新版本 检查系统资源占用 参考资源 PowerToys 官方文档 PowerToys GitHub PowerToys 插件市场 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/powertoys-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"PowerToys 使用指南"},{"content":"为什么需要管理C盘空间？ 在 Windows 系统中，C 盘作为系统主分区，存储着：\n操作系统文件（Windows 文件夹） 系统程序（Program Files） 用户配置文件 系统引导文件 C盘空间不足可能导致：\n系统运行变慢 无法安装新软件 系统更新失败 文件损坏 系统不稳定 空间占用分析 1. 软件安装位置 很多软件默认安装在C盘的原因：\n标准化与兼容性\n默认安装到 Program Files 文件夹 更好的系统整合性 避免兼容性问题 访问权限与路径依赖\nC盘是系统管理员控制的分区 软件依赖特定路径存储资源 系统API默认路径指向C盘 2. 应用数据存储 即使软件安装在其他盘，仍可能在C盘占用空间：\n用户配置文件（C:\\Users\\用户名\\AppData） 缓存文件 临时文件 日志文件 空间优化方案 1. 软件安装优化 使用包管理器安装\n推荐使用 Scoop 安装软件 可自定义安装路径 便于管理和更新 自定义安装路径\n安装时修改默认路径 选择其他磁盘分区 避免安装在C盘 2. 应用数据迁移 使用 WizTree 分析空间占用 安装 WizTree\n1 scoop install wiztree 扫描分析\n快速扫描磁盘 可视化空间占用 定位大文件/文件夹 常见大空间占用目录 开发工具\nJetBrains IDE：C:\\Users\\用户名\\AppData\\Local\\JetBrains Unity：C:\\Users\\用户名\\AppData\\Local\\Unity Visual Studio：C:\\Users\\用户名\\AppData\\Local\\Microsoft\\VisualStudio 应用缓存\nChrome：C:\\Users\\用户名\\AppData\\Local\\Google\\Chrome\\User Data Firefox：C:\\Users\\用户名\\AppData\\Local\\Mozilla\\Firefox\\Profiles Edge：C:\\Users\\用户名\\AppData\\Local\\Microsoft\\Edge\\User Data 迁移步骤 移动文件夹\n1 2 3 4 5 # 创建目标目录 New-Item -ItemType Directory -Force -Path \u0026#34;G:\\AppData\\JetBrains\u0026#34; # 移动文件夹 Move-Item -Path \u0026#34;C:\\Users\\用户名\\AppData\\Local\\JetBrains\u0026#34; -Destination \u0026#34;G:\\AppData\\JetBrains\u0026#34; 创建符号链接\n1 2 # 需要管理员权限 New-Item -ItemType SymbolicLink -Path \u0026#34;C:\\Users\\用户名\\AppData\\Local\\JetBrains\u0026#34; -Target \u0026#34;G:\\AppData\\JetBrains\u0026#34; 3. 系统清理 清理临时文件\n1 2 3 4 5 # 清理 Windows 临时文件 Remove-Item -Path \u0026#34;$env:TEMP\\*\u0026#34; -Recurse -Force # 清理系统临时文件 Remove-Item -Path \u0026#34;C:\\Windows\\Temp\\*\u0026#34; -Recurse -Force 清理系统更新缓存\n1 2 # 清理 Windows 更新缓存 Remove-Item -Path \u0026#34;C:\\Windows\\SoftwareDistribution\\Download\\*\u0026#34; -Recurse -Force 清理回收站\n1 2 # 清空回收站 Clear-RecycleBin -Force 注意事项 备份重要数据\n迁移前备份重要文件 记录原始路径 保存配置信息 权限管理\n使用管理员权限执行命令 确保目标路径有写入权限 检查文件访问权限 系统稳定性\n迁移后测试软件功能 检查系统更新 监控系统性能 定期维护 定期清理\n清理临时文件 删除不需要的软件 整理用户文件 空间监控\n使用 WizTree 定期扫描 监控空间变化 及时处理大文件 软件管理\n及时更新软件 卸载不常用软件 使用包管理器管理 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/windows-c%E7%9B%98%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/","title":"Windows C盘空间优化指南"},{"content":"简介 Windows Terminal 是一个现代化、多标签的终端应用程序，专为使用命令行工具设计。它提供了许多强大且灵活的功能，可以替代经典的命令提示符和 PowerShell 窗口。\n主要特性：\n多标签页支持 分屏功能 自定义主题 丰富的快捷键 支持多种 Shell（PowerShell、CMD、WSL 等） 安装 安装方式 Microsoft Store\n直接安装 优点：自动更新，安装简单 GitHub 发布页\n下载最新版本 优点：可以获取最新特性 包管理器安装（推荐）\n1 2 3 4 5 # 使用 scoop 安装 scoop install windows-terminal # 使用 winget 安装 winget install Microsoft.WindowsTerminal 安装 PowerShell Core Windows Terminal 推荐使用 PowerShell Core（跨平台版本）而不是系统自带的 PowerShell：\n1 2 # 使用 scoop 安装 scoop install powershell 基础配置 常用快捷键 功能 快捷键 新建标签页 Ctrl + Shift + T 切换标签页 Ctrl + Tab 右分屏 Alt + Shift + + 下分屏 Alt + Shift + - 打开设置 Ctrl + , 打开命令面板 Ctrl + Shift + P 自定义快捷键 在 settings.json 中配置自定义快捷键：\n1 2 3 4 5 6 7 8 9 { \u0026#34;keybindings\u0026#34;: [ { \u0026#34;command\u0026#34;: \u0026#34;newTab\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+shift+p\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;PowerShell\u0026#34; } ] } 美化配置 1. 配置字体 下载等宽字体\n推荐使用 Cascadia Code PL 其他选择：JetBrains Mono、Fira Code 配置字体设置\n1 2 3 4 5 6 7 8 { \u0026#34;defaults\u0026#34;: { \u0026#34;font\u0026#34;: { \u0026#34;face\u0026#34;: \u0026#34;Cascadia Code PL\u0026#34;, \u0026#34;size\u0026#34;: 10.0 } } } 2. 配置 oh-my-posh 安装 oh-my-posh 1 2 3 4 5 6 7 8 # 使用 winget 安装（推荐） winget install JanDeDobbeleer.OhMyPosh -l D:\\Tools\\oh-my-posh # 使用 scoop 安装 scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json # 验证安装 oh-my-posh --version 更新 oh-my-posh 1 2 3 4 5 # 使用 winget 更新 winget upgrade JanDeDobbeleer.OhMyPosh # 使用 scoop 更新 scoop update oh-my-posh 配置主题 下载主题\n主题预览 主题仓库 推荐主题： powerlevel10k_lean cobalt2 保存主题文件\n1 2 3 4 5 # 创建主题目录 New-Item -ItemType Directory -Force -Path \u0026#34;D:\\Tools\\oh-my-posh\\themes\u0026#34; # 下载主题文件 Invoke-WebRequest -Uri \u0026#34;https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/powerlevel10k_lean.omp.json\u0026#34; -OutFile \u0026#34;D:\\Tools\\oh-my-posh\\themes\\powerlevel10k_lean.omp.json\u0026#34; 配置 PowerShell 配置文件\n1 2 3 4 5 # 创建配置文件 if (!(Test-Path -Path $PROFILE)) { New-Item -Type File -Path $PROFILE -Force } # 编辑配置文件 code $PROFILE 添加配置内容\n1 2 3 4 5 6 7 8 9 10 # 初始化 oh-my-posh oh-my-posh init pwsh --config D:\\Tools\\oh-my-posh\\themes\\powerlevel10k_lean.omp.json | Invoke-Expression # 配置命令补全 Import-Module PSReadLine Set-PSReadLineOption -PredictionSource History Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete # 清屏 cls 验证配置\n1 2 3 4 5 # 重新加载配置文件 . $PROFILE # 检查 oh-my-posh 是否正确加载 $env:POSH_THEMES_PATH 实用功能 1. 代理管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 开启代理 function proxy-on { param($proxy = \u0026#34;http://127.0.0.1:1080\u0026#34;) $env:http_proxy = $proxy $env:https_proxy = $proxy Write-Host \u0026#34;代理已开启: $proxy\u0026#34; } # 关闭代理 function proxy-off { $env:http_proxy = \u0026#34;\u0026#34; $env:https_proxy = \u0026#34;\u0026#34; Write-Host \u0026#34;代理已关闭\u0026#34; } 2. 快速打开文件夹 1 2 3 4 5 # 打开文件夹 function open { param($path = \u0026#34;.\u0026#34;) explorer.exe $path } 3. 环境变量管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 设置环境变量 function set-env { param( [string]$key, [string]$value, [string]$scope = \u0026#34;u\u0026#34; # u: 用户, m: 系统 ) if ($scope -eq \u0026#34;u\u0026#34;) { [System.Environment]::SetEnvironmentVariable($key, $value, \u0026#34;User\u0026#34;) } else { [System.Environment]::SetEnvironmentVariable($key, $value, \u0026#34;Machine\u0026#34;) } Write-Host \u0026#34;环境变量已设置: $key = $value\u0026#34; } 配置文件 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/windows-terminal-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Windows Terminal 使用指南"},{"content":"软件安装方式 Windows 系统安装应用的方式主要有以下几种：\n包管理器安装\n优点：自动化、便捷、可重复 缺点：部分软件可能不支持 适用场景：开发工具、常用软件 Microsoft Store 安装\n优点：安全、自动更新 缺点：软件数量有限 适用场景：UWP 应用、系统工具 安装包安装\n优点：最通用、功能完整 缺点：手动操作、可能捆绑 适用场景：大型软件、特殊软件 包管理器介绍 包管理器的优势 自动化管理\n一键安装/卸载 批量更新 依赖处理 版本控制 安全性\n官方源 签名验证 安全更新 便捷性\n命令行操作 配置备份 环境迁移 一致性\n统一安装流程 标准配置 可重复部署 Windows 主流包管理器 1. Scoop（推荐） 特点：\n绿色软件，无需管理员权限 用户目录安装，不影响系统 配置简单，支持多版本共存 软件库相对较少，更新可能不够及时 安装步骤：\n1 2 3 4 5 6 # 设置 PowerShell 执行策略 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser # 安装 Scoop irm get.scoop.sh -outfile \u0026#39;install.ps1\u0026#39; .\\install.ps1 -ScoopDir \u0026#39;D:\\Applications\\Scoop\u0026#39; -ScoopGlobalDir \u0026#39;F:\\GlobalScoopApps\u0026#39; -NoProxy 常用命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # 搜索软件 scoop search \u0026lt;app_name\u0026gt; # 安装软件 scoop install \u0026lt;app_name\u0026gt; # 更新软件 scoop update \u0026lt;app_name\u0026gt; # 卸载软件 scoop uninstall \u0026lt;app_name\u0026gt; # 查看已安装软件 scoop list # 高级命令 # 设置代理 scoop config proxy 127.0.0.1:1080 # 查看帮助 scoop --help # 查看版本 scoop --version # 查看缓存 scoop cache list # 清理缓存 scoop cache cleanup # 导出安装列表 scoop export \u0026gt; \u0026lt;file_name\u0026gt; # 导入安装列表 scoop import \u0026lt;file_name\u0026gt; # 清理未使用的应用 scoop cleanup # 重置 Scoop scoop reset Scoop 目录说明 Scoop 安装后会在指定目录创建以下文件夹：\napps：所有通过 scoop 安装的软件 buckets：软件仓库配置，默认包含 main 仓库 cache：下载的安装包临时存储 persist：用户数据持久化存储 shims：命令行工具软链接 仓库管理 添加仓库\n1 2 3 4 5 6 7 # 添加官方仓库 scoop bucket add extras scoop bucket add versions scoop bucket add java # 添加自定义仓库 scoop bucket add \u0026lt;仓库名\u0026gt; \u0026lt;仓库URL\u0026gt; 查看仓库\n1 2 3 4 5 # 列出所有仓库 scoop bucket list # 查看仓库软件 scoop search \u0026lt;软件名\u0026gt; 更新仓库\n1 2 3 4 5 # 更新所有仓库 scoop update # 更新特定仓库 scoop update \u0026lt;仓库名\u0026gt; 2. WinGet 特点：\n微软官方维护，安全性高 系统原生集成，无需额外安装 支持 Microsoft Store 和 UWP 应用 软件库较少，功能相对简单 安装方式：\nMicrosoft Store 安装\nGitHub 下载安装\n通过 Scoop 安装（推荐）：\n1 scoop install winget 常用命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 搜索软件 winget search \u0026lt;app_name\u0026gt; # 安装软件 winget install \u0026lt;app_name\u0026gt; # 指定安装路径 winget install -l \u0026lt;app_name\u0026gt; # 交互式安装 winget install -i \u0026lt;app_name\u0026gt; # 高级命令 # 查看已安装软件 winget list # 更新软件 winget upgrade # 卸载软件 winget uninstall \u0026lt;app_name\u0026gt; # 查看软件信息 winget show \u0026lt;app_name\u0026gt; # 导出已安装软件列表 winget export -o \u0026lt;file_name\u0026gt; # 从文件导入安装 winget import \u0026lt;file_name\u0026gt; 3. Chocolatey 特点：\n社区驱动，软件库最丰富 功能全面，支持多版本管理 需要管理员权限，配置较复杂 部分包更新不及时，安装较慢 安装方法：\n1 2 # 以管理员身份运行 PowerShell Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) 常用命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 搜索软件 choco search \u0026lt;app_name\u0026gt; # 安装软件 choco install \u0026lt;app_name\u0026gt; # 更新软件 choco upgrade \u0026lt;app_name\u0026gt; # 卸载软件 choco uninstall \u0026lt;app_name\u0026gt; # 查看已安装软件 choco list --local-only # 更新所有软件 choco upgrade all # 查看软件信息 choco info \u0026lt;app_name\u0026gt; 软件安装最佳实践 1. 包管理器安装 优先使用包管理器安装软件，特别是开发工具和常用软件。\n2. 安装包安装 对于无法通过包管理器安装的软件：\n下载来源\n官方网站 可信第三方 避免破解版 安装步骤\n修改安装路径 取消捆绑软件 注意安装选项 安装后检查\n验证功能 检查启动项 清理临时文件 推荐软件 开发工具 编辑器\nVSCode（scoop install vscode）：功能强大的代码编辑器，支持丰富的插件和扩展 Sublime Text（scoop install sublime-text）：轻量级高性能编辑器，适合快速编辑 终端工具\nWindows Terminal（scoop install windows-terminal）：现代化的终端模拟器，支持多标签和分屏 Git（scoop install git）：版本控制工具，必备开发工具 开发工具\nADB（scoop install adb）：Android 调试工具，用于移动应用开发 APKTool（scoop install apktool）：Android 应用反编译工具 系统工具 压缩工具\n7-Zip（scoop install 7zip）：高效的文件压缩工具，支持多种格式 搜索工具\nEverything（scoop install everything）：快速的文件搜索工具，支持实时索引 系统优化\nCCleaner（scoop install ccleaner）：系统清理和优化工具 实用工具 下载工具\nAria2（scoop install aria2）：多协议下载工具，支持断点续传 PDF阅读器\nFoxit Reader（scoop install foxit-pdf-reader）：轻量级 PDF 阅读器，支持编辑功能 视频播放器\nPotPlayer（scoop install potplayer）：功能强大的视频播放器，支持多种格式 截图工具\nShareX（scoop install sharex）：功能丰富的截图和录屏工具 自动化工具 快捷键工具 AutoHotkey（scoop install autohotkey）：强大的自动化脚本工具 PowerToys（scoop install powertoys）：微软官方工具集，提供多种系统增强功能 配置文件 AutoHotkey 配置 基本语法：\n1 2 3 4 5 6 7 # 代表 Win 键 ! 代表 Alt 键 ^ 代表 Ctrl 键 + 代表 Shift 键 :: 分隔符 run 运行命令 ; 注释 示例配置：\n1 2 3 4 5 6 7 8 # 打开网站 #g::run https://github.com # 打开应用 #v::run code # 快捷键组合 #!v::run notepad 配置下载 scoop 列表下载 autohotkey 配置下载 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/windows-%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/","title":"Windows 系统软件安装指南"},{"content":"准备工作 1. 备份重要数据 在重装系统前，请确保：\n备份重要文档、图片等个人文件 导出浏览器书签和密码 记录已安装的软件列表 保存系统激活信息（如果有） 2. 下载系统镜像 Windows 11 下载 访问官方下载页面 选择 Windows 11 版本（建议选择最新版本） 选择语言（建议选择简体中文） 点击下载按钮，等待下载完成 Windows 10 下载 访问官方下载页面 由于页面限制，需要修改浏览器 UA 才能下载 ISO 文件 修改 UA 方法：\nChrome 浏览器：\n打开开发者工具（F12） More Tools -\u0026gt; Network conditions User agent 修改为 BlackBerry-BB10 Edge 浏览器：\n打开开发者工具（F12） 在底部选择网络条件 将用户代理修改为 BlackBerry-BB10 修改 UA 后刷新页面，即可选择对应的 ISO 文件下载。\n3. 准备启动工具 下载 WePE（推荐使用最新版本） 准备一个 8GB 以上的 U 盘 使用 WePE 制作启动盘（注意：此过程会格式化 U 盘，请提前备份数据） 重装系统 1. 进入 BIOS 重启电脑 在开机时按特定按键进入 BIOS（常见按键：F2、F10、Del、Esc） 找到 Boot 选项 将 U 盘设置为第一启动项 保存设置并退出 2. 安装系统 进入 WinPE 系统 使用分区工具（如 DiskGenius）进行分区（如果需要） 运行系统安装程序 选择系统镜像文件 选择安装位置（通常是 C 盘） 等待安装完成 3. 首次启动设置 设置系统语言和输入法 创建用户账户 设置密码（建议设置） 配置隐私选项 等待系统完成初始化 4. 跳过联网激活（可选） Windows 11 首次启动时需要联网激活，可以通过以下方法跳过：\n在首次启动界面，按 Shift + F10 打开命令提示符 输入以下命令： 1 oobe\\bypassnro.cmd 系统会自动重启 重启后，在联网界面选择\u0026quot;我没有 Internet 连接\u0026quot; 继续完成设置即可 注意：跳过联网激活后，建议在系统设置完成后手动连接网络并激活系统。\n系统优化 1. 安装必要驱动 检查设备管理器 下载并安装主板驱动 安装显卡驱动 安装网卡驱动 安装其他设备驱动 2. 系统更新 检查 Windows 更新 安装所有重要更新 安装可选更新（根据需要） ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/windows-%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%8C%87%E5%8D%97/","title":"Windows 系统重装指南"},{"content":"什么是 WSL？ WSL (Windows Subsystem for Linux) 是微软开发的一个工具，允许用户在 Windows 系统上直接运行 Linux 二进制可执行文件。这意味着你可以在 Windows 上运行一个完整的 Linux 环境，而无需虚拟机或双启动配置。\nWSL 的主要优势 无缝集成\n直接在 Windows 上运行 Linux 环境 无需虚拟机或双启动配置 可以同时使用 Windows 和 Linux 的功能 开发效率\n支持 Linux 命令行工具（Bash、Git、SSH 等） 可以直接访问 Windows 文件系统 适合 Web 开发、数据科学等场景 性能优势\n比传统虚拟机更轻量级 启动速度快 资源占用少 WSL 版本对比 WSL 1 特点：轻量级，直接将 Linux 调用映射到 Windows 内核 优势： 启动速度快 适合文件操作较多的任务 与 Windows 文件系统集成更好 限制： 不支持完整的 Linux 内核功能 性能相对较低 WSL 2 特点：使用完整的 Linux 内核，基于轻量级虚拟机 优势： 更好的性能 完整的 Linux 内核兼容性 支持 Docker 等容器技术 限制： 启动时间稍长 需要更多系统资源 推荐：建议使用 WSL 2，因为它提供更好的性能和更完整的 Linux 功能支持。\n安装指南 系统要求 Windows 10 版本 2004 及以上（内部版本 19041 及以上） Windows 11 开启必要的 Windows 功能 1. 开启 Hyper-V 1 2 # 以管理员身份运行 PowerShell，执行以下命令 dism.exe /online /enable-feature /featurename:Microsoft-Hyper-V /all /norestart 2. 开启虚拟机平台 1 2 # 以管理员身份运行 PowerShell，执行以下命令 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 3. 开启 Windows Subsystem for Linux 1 2 # 以管理员身份运行 PowerShell，执行以下命令 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 注意：执行完这些命令后需要重启计算机。\n安装方式 1. 便捷安装（推荐） 使用 wsl 命令安装，参考官方文档：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 安装 Ubuntu（默认） wsl --install # 查看可下载的 Linux 发行版 wsl --list --online # 或使用简写 wsl -l -o # 安装指定发行版 wsl --install -d \u0026lt;Distribution Name\u0026gt; # 查看已安装的发行版和版本 wsl -l -v # 设置默认版本 wsl --set-default-version 2 # 推荐使用 WSL 2 # 删除 Linux 发行版 wsl --unregister \u0026lt;Distribution Name\u0026gt; 2. 手动安装 安装 WSL2 内核\n下载 WSL2 内核更新包 安装下载的更新包 设置 WSL 版本\n1 wsl --set-default-version 2 安装 Linux 发行版\n访问 Microsoft Store 选择并安装需要的 Linux 发行版 基础配置 1. 设置 root 用户 1 sudo passwd root 2. 配置代理 1 2 3 4 5 # 设置 HTTP 代理 export http_proxy=http://127.0.0.1:1080 # 设置 HTTPS 代理 export https_proxy=http://127.0.0.1:1080 3. 更新系统 1 2 sudo apt update sudo apt upgrade 终端美化 安装 oh-my-zsh 安装 zsh\n1 sudo apt-get install zsh 安装 oh-my-zsh\n1 2 3 4 5 6 7 8 9 10 11 # 克隆 oh-my-zsh 仓库 git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh # 复制配置文件 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc # 应用配置 source ~/.zshrc # 设置默认 shell chsh -s /bin/zsh 配置主题 安装 Powerlevel10k 主题\n1 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/.oh-my-zsh/themes/powerlevel10k 修改主题配置\n编辑 ~/.zshrc 文件\n设置主题：\n1 ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; 应用配置\n1 source ~/.zshrc 查看当前主题\n1 echo $ZSH_THEME 配置插件 内置插件\n插件目录：~/.oh-my-zsh/plugins\n编辑 ~/.zshrc 文件，添加需要的插件：\n1 plugins=(git zsh-syntax-highlighting) 第三方插件\n在 ~/.zshrc 文件中添加：\n1 source \u0026lt;/path/to/plugin\u0026gt; 常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 启动 WSL wsl # 启动指定发行版 wsl -d \u0026lt;Distribution Name\u0026gt; # 关闭 WSL wsl --shutdown # 查看 WSL 状态 wsl --status # 导出 WSL 发行版 wsl --export \u0026lt;Distribution Name\u0026gt; \u0026lt;FileName\u0026gt; # 导入 WSL 发行版 wsl --import \u0026lt;Distribution Name\u0026gt; \u0026lt;InstallLocation\u0026gt; \u0026lt;FileName\u0026gt; 参考资源 WSL 官方文档 oh-my-zsh 文档 Powerlevel10k 主题 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/wsl-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"WSL 使用指南"},{"content":"问题描述 在 Windows 系统中，即使你的账户是管理员账户，也可能无法直接访问 C:\\Program Files\\WindowsApps 文件夹。这是因为该文件夹受到特殊权限保护，属于系统受限区域，主要用于存储 Microsoft Store 应用程序的数据。为了防止意外修改或恶意操作，Windows 默认限制了对该文件夹的访问权限，即使是管理员用户也需要额外步骤才能进入。\n原因分析 权限限制\nWindowsApps 文件夹的所有权通常属于系统账户（如 TrustedInstaller） 普通管理员账户没有直接访问权限 系统默认限制了对该文件夹的访问 UAC（用户账户控制）\n即使使用管理员账户，UAC 可能仍然要求额外的权限提升 系统安全机制限制了对系统文件夹的直接访问 文件夹保护机制\n该文件夹默认是隐藏的 受到 Windows 文件保护机制的限制 属于系统关键目录 解决方案 步骤 1：显示隐藏文件夹 打开文件资源管理器 点击顶部菜单的\u0026quot;查看\u0026quot; \u0026gt; \u0026ldquo;选项\u0026rdquo; \u0026gt; \u0026ldquo;查看\u0026quot;选项卡 在\u0026quot;高级设置\u0026quot;中： 勾选\u0026quot;显示隐藏的文件、文件夹和驱动器\u0026rdquo; 取消勾选\u0026quot;隐藏受保护的操作系统文件\u0026quot; 点击\u0026quot;应用\u0026quot;和\u0026quot;确定\u0026quot; 步骤 2：获取文件夹访问权限 打开文件夹属性\n右键点击 C:\\Program Files\\WindowsApps 文件夹 选择\u0026quot;属性\u0026quot; 修改安全设置\n切换到\u0026quot;安全\u0026quot;选项卡 点击\u0026quot;高级\u0026quot;按钮 更改所有者\n在\u0026quot;高级安全设置\u0026quot;窗口中，检查\u0026quot;所有者\u0026quot;是否为 TrustedInstaller 点击\u0026quot;更改\u0026quot;所有者 输入你的用户名（例如：你的电脑名\\你的用户名） 点击\u0026quot;检查名称\u0026quot;确认 查看当前用户名\n1 2 # 在命令提示符或 PowerShell 中执行 whoami 应用权限更改\n勾选\u0026quot;替换子容器和对象的所有者\u0026quot; 点击\u0026quot;确定\u0026quot;保存更改 添加完全控制权限\n返回\u0026quot;安全\u0026quot;选项卡 点击\u0026quot;编辑\u0026quot;按钮 为你的账户添加\u0026quot;完全控制\u0026quot;权限 点击\u0026quot;应用\u0026quot;和\u0026quot;确定\u0026quot; 注意事项 谨慎操作\n修改系统文件夹权限可能导致系统问题 建议在修改前备份重要数据 如非必要，不建议修改系统文件夹权限 潜在风险\n修改系统文件夹可能导致应用程序无法正常运行 可能影响系统更新和应用程序更新 可能触发系统安全机制 最佳实践\n仅在必要时访问该文件夹 完成操作后建议恢复原始权限 保持系统安全性的同时满足访问需求 参考资源 Windows 文件权限管理 Windows 安全最佳实践 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE-windowsapps-%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","title":"无法访问 WindowsApps 文件夹的解决方案"},{"content":"问题背景 当 Unity 导出 Android APK 时，如果项目使用了大量的第三方 SDK 或库，很容易达到 Android 方法数 65536 的限制。这是因为：\nAndroid 的 DEX 文件格式限制每个 APK 最多包含 65536 个方法 现代游戏开发中经常使用多个第三方 SDK Unity 项目本身也会引入大量方法 开发环境 Unity 2022.3.46f1 Android Gradle Plugin 7.3.1 Android SDK 33 minSdkVersion 21 targetSdkVersion 33 MultiDex 解决方案 1. 基础配置 开启 Gradle 构建\n在 Unity 中：Edit \u0026gt; Project Settings \u0026gt; Player \u0026gt; Android 勾选 \u0026ldquo;Custom Main Gradle Template\u0026rdquo; 勾选 \u0026ldquo;Custom Gradle Properties Template\u0026rdquo; 配置 Gradle 文件\n路径：Assets/Plugins/Android/mainTemplate.gradle 1 2 3 4 5 6 7 8 9 10 android { defaultConfig { minSdkVersion 21 targetSdkVersion 33 multiDexEnabled true // 启用 R8 优化 minifyEnabled true proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-unity.txt\u0026#39; } } 2. 依赖配置 AndroidX 支持\n1 2 3 4 dependencies { implementation \u0026#39;androidx.multidex:multidex:2.0.1\u0026#39; // 其他依赖... } 旧版支持库\n1 2 3 4 dependencies { implementation \u0026#39;com.android.support:multidex:1.0.3\u0026#39; // 其他依赖... } 3. Application 配置 修改 Assets/Plugins/Android/AndroidManifest.xml：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; package=\u0026#34;com.yourcompany.gamename\u0026#34;\u0026gt; \u0026lt;application android:name=\u0026#34;androidx.multidex.MultiDexApplication\u0026#34; android:allowBackup=\u0026#34;true\u0026#34; android:icon=\u0026#34;@drawable/app_icon\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:theme=\u0026#34;@style/UnityThemeSelector\u0026#34;\u0026gt; \u0026lt;!-- 其他配置... --\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 性能优化 1. 启动优化 预加载配置\n1 2 3 4 5 6 android { defaultConfig { // 启用预加载 multiDexKeepProguard file(\u0026#39;multidex-config.pro\u0026#39;) } } 主 DEX 配置\n创建 multidex-config.pro 文件 指定需要预加载的类 2. 构建优化 R8 优化\n1 2 3 4 5 6 7 8 9 android { buildTypes { release { minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-unity.txt\u0026#39; } } } DEX 优化\n1 2 3 4 5 6 7 android { dexOptions { preDexLibraries true maxProcessCount 8 javaMaxHeapSize \u0026#34;4g\u0026#34; } } 注意事项 版本兼容\nAndroid 5.0 (API 21) 以上默认支持 MultiDex 低版本需要额外配置 性能影响\n首次启动时间可能增加 内存占用可能增加 需要合理优化 调试建议\n使用 Android Studio 的 APK Analyzer 监控启动时间 检查内存使用 参考资源 Google MultiDex 官方文档 Unity Android 构建文档 Android Gradle Plugin 文档 ","date":"2024-03-05T16:03:30+08:00","permalink":"https://imhy.top/p/unity-%E4%BD%BF%E7%94%A8-multidex-%E5%BA%93/","title":"Unity 使用 MultiDex 库"},{"content":"小游戏更新机制 微信小游戏开发文档中描述了两种更新机制：\n1. 静默更新 特点：无需用户操作，自动更新 时机：微信客户端会在多个时机检查更新 限制：无法立即影响所有用户 时间：最长 24 小时内完成更新 2. 启动时更新 特点：冷启动时检查更新 流程： 检查新版本 异步下载新版本 使用本地包启动 下次冷启动应用新版本 冷启动说明 根据小程序运行机制文档，冷启动是指：\n用户首次打开小游戏 小游戏被销毁后再次打开 注意：关闭小游戏并不会立即触发销毁，需要满足以下条件之一：\n进入后台一定时间 系统资源占用过高 强制更新原因 在某些情况下，我们需要强制用户更新到最新版本，主要包括：\n1. 功能兼容性 新版本包含重要的功能更新 旧版本可能无法正常运行新功能 需要确保所有用户使用相同版本的功能 2. 安全性考虑 修复了严重的安全漏洞 防止用户使用存在安全隐患的版本 保护用户数据和账号安全 3. 游戏平衡性 修复了影响游戏平衡的 bug 更新了游戏规则或机制 确保所有玩家在公平的环境下游戏 4. 运营需求 新版本包含重要的运营活动 需要统一用户版本以支持新活动 确保活动规则对所有玩家一致 5. 技术维护 修复了导致崩溃的严重 bug 优化了游戏性能 减少了服务器压力 强制更新实现 1. 基础实现 1 2 3 4 5 6 7 8 9 10 11 12 13 var updateManager = WX.GetUpdateManager(); updateManager.OnCheckForUpdate(res =\u0026gt; { // noting }); updateManager.OnUpdateFailed(res =\u0026gt; { // show error tips }); updateManager.OnUpdateReady(res =\u0026gt; { // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 updateManager.ApplyUpdate(); }); 参考资源 微信小游戏更新机制文档 微信小游戏运行机制文档 微信小游戏开发文档 ","date":"2024-03-05T16:03:30+08:00","permalink":"https://imhy.top/p/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7/","title":"微信小游戏版本升级"}]