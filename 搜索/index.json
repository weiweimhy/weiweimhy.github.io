[{"content":"数值类型 整数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 // 有符号整数 var i8 int8 // -128 到 127 var i16 int16 // -32768 到 32767 var i32 int32 // -2147483648 到 2147483647 var i64 int64 // -9223372036854775808 到 9223372036854775807 var i int // 32位或64位，取决于系统 // 无符号整数 var u8 uint8 // 0 到 255 var u16 uint16 // 0 到 65535 var u32 uint32 // 0 到 4294967295 var u64 uint64 // 0 到 18446744073709551615 var u uint // 32位或64位，取决于系统 浮点数类型 1 2 3 var f32 float32 // 32位浮点数 var f64 float64 // 64位浮点数 var f float // float64 的别名 复数类型 1 2 3 var c64 complex64 // 64位复数 var c128 complex128 // 128位复数 var c complex // complex128 的别名 字符串 字符串特性 字符串是不可变的 支持 UTF-8 编码 可以使用反引号创建原始字符串 字符串操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 字符串声明 var s1 string = \u0026#34;Hello\u0026#34; s2 := \u0026#34;World\u0026#34; // 原始字符串 s3 := `This is a raw string with multiple lines` // 字符串连接 s4 := s1 + \u0026#34; \u0026#34; + s2 // 字符串长度 length := len(s1) // 字符串切片 sub := s1[1:3] // \u0026#34;el\u0026#34; 布尔类型 布尔值 1 2 3 4 5 6 7 var b1 bool = true var b2 bool = false // 布尔运算 b3 := true \u0026amp;\u0026amp; false // 与 b4 := true || false // 或 b5 := !true // 非 类型转换 数值类型转换 1 2 3 4 5 6 7 8 9 10 11 // 整数转换 var i int = 42 var f float64 = float64(i) // 浮点数转换 var f2 float64 = 3.14 var i2 int = int(f2) // 截断小数部分 // 字符串转换 var s string = strconv.Itoa(42) // 整数转字符串 i3, _ := strconv.Atoi(\u0026#34;42\u0026#34;) // 字符串转整数 常量 常量声明 1 2 3 4 5 6 7 8 9 10 11 12 13 // 单个常量 const Pi = 3.14159 // 多个常量 const ( Sunday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) 参考资源 Go 语言规范 Go 基础类型文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/5.-go-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"5. Go 基础数据类型"},{"content":"数组 数组比较 数组比较时，首先比较数组长度 如果数组长度相同并且每个元素都相同，则两个数组相等 不同数据类型的数组比较会报编译错误 数组作为参数 数组作为参数传递时会复制整个数组 函数内对数组的操作都是针对复制体 传递大数组时效率较低 可以通过指针传递数组以提高效率 1 2 3 4 5 6 7 8 9 10 // 使用指针传递数组 func zero(ptr *[32]byte) { *ptr = [32]byte{} } // 使用示例 func main() { var arr [32]byte zero(\u0026amp;arr) } 切片 切片特性 切片是对数组的引用 切片可以动态增长 切片作为参数传递时只传递引用 切片操作 1 2 3 4 5 6 7 8 // 创建切片 s := make([]int, 5, 10) // 长度为5，容量为10的切片 // 追加元素 s = append(s, 1, 2, 3) // 截取切片 s1 := s[1:3] // 包含索引1，不包含索引3 Map Map 特性 Map 是引用类型，零值为 nil Map 不是并发安全的，需要加锁保护 Map 的键必须是可比较的类型 Map 的迭代顺序是随机的 Map 操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 创建 map m := make(map[string]int) // 添加或更新键值对 m[\u0026#34;key\u0026#34;] = 1 // 删除键值对 delete(m, \u0026#34;key\u0026#34;) // 检查键是否存在 if value, ok := m[\u0026#34;key\u0026#34;]; ok { fmt.Printf(\u0026#34;值: %d\\n\u0026#34;, value) } // 并发安全的 map var syncMap sync.Map syncMap.Store(\u0026#34;key\u0026#34;, 1) value, _ := syncMap.Load(\u0026#34;key\u0026#34;) Channel Channel 特性 Channel 是引用类型，零值为 nil Channel 必须使用 make 创建 Channel 可以是有缓冲或无缓冲的 关闭后的 channel 仍然可以读取数据 Channel 操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 创建无缓冲 channel ch := make(chan int) // 创建有缓冲 channel ch := make(chan int, 10) // 发送数据 ch \u0026lt;- 1 // 接收数据 value := \u0026lt;-ch // 关闭 channel close(ch) // 遍历 channel for v := range ch { fmt.Println(v) } 指针 指针特性 指针可以指向任何类型的变量 指针的零值是 nil 指针可以用于修改原变量的值 指针使用 1 2 3 4 5 // 指针声明和使用 var p *int i := 42 p = \u0026amp;i *p = 21 // 通过指针修改值 结构体 结构体特性 结构体字段可以导出（首字母大写） 结构体可以嵌入其他结构体 结构体可以实现接口 结构体示例 1 2 3 4 5 6 7 8 9 type Person struct { Name string Age int } // 结构体方法 func (p *Person) SetAge(age int) { p.Age = age } 接口 接口特性 接口是隐式实现的 接口可以组合 空接口可以存储任何类型的值 接口示例 1 2 3 4 5 6 7 8 9 10 11 12 13 type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } // 接口组合 type ReadWriter interface { Reader Writer } 参考资源 Go 语言规范 Go 数据类型文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/6.-go-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","title":"6. Go 数据类型注意事项"},{"content":"文件操作基础 打开文件 1 2 3 4 5 6 7 8 9 10 11 12 13 // 打开文件 file, err := os.Open(\u0026#34;example.txt\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() // 创建文件 file, err := os.Create(\u0026#34;newfile.txt\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() 读取文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 读取整个文件 data, err := os.ReadFile(\u0026#34;example.txt\u0026#34;) if err != nil { log.Fatal(err) } // 按行读取 file, err := os.Open(\u0026#34;example.txt\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { line := scanner.Text() fmt.Println(line) } 写入文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 写入字符串 err := os.WriteFile(\u0026#34;output.txt\u0026#34;, []byte(\u0026#34;Hello, World!\u0026#34;), 0644) if err != nil { log.Fatal(err) } // 追加写入 file, err := os.OpenFile(\u0026#34;output.txt\u0026#34;, os.O_APPEND|os.O_WRONLY, 0644) if err != nil { log.Fatal(err) } defer file.Close() _, err = file.WriteString(\u0026#34;追加的内容\u0026#34;) if err != nil { log.Fatal(err) } 目录操作 创建目录 1 2 3 4 5 6 7 8 9 10 11 // 创建单个目录 err := os.Mkdir(\u0026#34;newdir\u0026#34;, 0755) if err != nil { log.Fatal(err) } // 创建多级目录 err := os.MkdirAll(\u0026#34;path/to/dir\u0026#34;, 0755) if err != nil { log.Fatal(err) } 遍历目录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 读取目录内容 entries, err := os.ReadDir(\u0026#34;.\u0026#34;) if err != nil { log.Fatal(err) } for _, entry := range entries { fmt.Println(entry.Name()) } // 递归遍历目录 func walkDir(dir string) { entries, err := os.ReadDir(dir) if err != nil { log.Fatal(err) } for _, entry := range entries { path := filepath.Join(dir, entry.Name()) if entry.IsDir() { walkDir(path) } else { fmt.Println(path) } } } 文件信息 获取文件信息 1 2 3 4 5 6 7 8 9 10 // 获取文件信息 fileInfo, err := os.Stat(\u0026#34;example.txt\u0026#34;) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;文件名: %s\\n\u0026#34;, fileInfo.Name()) fmt.Printf(\u0026#34;大小: %d bytes\\n\u0026#34;, fileInfo.Size()) fmt.Printf(\u0026#34;修改时间: %v\\n\u0026#34;, fileInfo.ModTime()) fmt.Printf(\u0026#34;权限: %v\\n\u0026#34;, fileInfo.Mode()) 检查文件状态 1 2 3 4 5 6 7 8 9 // 检查文件是否存在 if _, err := os.Stat(\u0026#34;example.txt\u0026#34;); os.IsNotExist(err) { fmt.Println(\u0026#34;文件不存在\u0026#34;) } // 检查是否是目录 if fileInfo.IsDir() { fmt.Println(\u0026#34;这是一个目录\u0026#34;) } 临时文件 创建临时文件 1 2 3 4 5 6 7 8 9 10 11 12 // 创建临时文件 tmpFile, err := os.CreateTemp(\u0026#34;\u0026#34;, \u0026#34;example-*.txt\u0026#34;) if err != nil { log.Fatal(err) } defer os.Remove(tmpFile.Name()) // 写入临时文件 content := []byte(\u0026#34;临时文件内容\u0026#34;) if _, err := tmpFile.Write(content); err != nil { log.Fatal(err) } 文件路径操作 路径处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 路径拼接 path := filepath.Join(\u0026#34;dir\u0026#34;, \u0026#34;subdir\u0026#34;, \u0026#34;file.txt\u0026#34;) // 获取绝对路径 absPath, err := filepath.Abs(\u0026#34;relative/path\u0026#34;) if err != nil { log.Fatal(err) } // 获取文件扩展名 ext := filepath.Ext(\u0026#34;file.txt\u0026#34;) // 获取文件名（不含扩展名） name := strings.TrimSuffix(\u0026#34;file.txt\u0026#34;, filepath.Ext(\u0026#34;file.txt\u0026#34;)) 参考资源 Go os 包文档 Go filepath 包文档 Go bufio 包文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/7.-go-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","title":"7. Go 文件操作"},{"content":"Goroutine 基本概念 Goroutine 是轻量级线程 由 Go 运行时管理 比线程更高效 创建和使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 启动 goroutine go func() { fmt.Println(\u0026#34;在 goroutine 中运行\u0026#34;) }() // 带参数的 goroutine go func(msg string) { fmt.Println(msg) }(\u0026#34;Hello\u0026#34;) // 等待 goroutine 完成 var wg sync.WaitGroup wg.Add(1) go func() { defer wg.Done() fmt.Println(\u0026#34;goroutine 完成\u0026#34;) }() wg.Wait() Channel Channel 类型 1 2 3 4 5 6 7 8 9 10 11 // 无缓冲 channel ch1 := make(chan int) // 有缓冲 channel ch2 := make(chan int, 10) // 只读 channel ch3 := make(\u0026lt;-chan int) // 只写 channel ch4 := make(chan\u0026lt;- int) Channel 操作 1 2 3 4 5 6 7 8 9 10 11 12 13 // 发送数据 ch \u0026lt;- 42 // 接收数据 value := \u0026lt;-ch // 关闭 channel close(ch) // 遍历 channel for v := range ch { fmt.Println(v) } 同步原语 WaitGroup 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var wg sync.WaitGroup func worker(id int) { defer wg.Done() fmt.Printf(\u0026#34;Worker %d 开始\\n\u0026#34;, id) time.Sleep(time.Second) fmt.Printf(\u0026#34;Worker %d 完成\\n\u0026#34;, id) } func main() { for i := 1; i \u0026lt;= 5; i++ { wg.Add(1) go worker(i) } wg.Wait() } Mutex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type SafeCounter struct { mu sync.Mutex count int } func (c *SafeCounter) Increment() { c.mu.Lock() defer c.mu.Unlock() c.count++ } func (c *SafeCounter) GetCount() int { c.mu.Lock() defer c.mu.Unlock() return c.count } RWMutex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type SafeMap struct { mu sync.RWMutex data map[string]interface{} } func (m *SafeMap) Get(key string) interface{} { m.mu.RLock() defer m.mu.RUnlock() return m.data[key] } func (m *SafeMap) Set(key string, value interface{}) { m.mu.Lock() defer m.mu.Unlock() m.data[key] = value } 并发模式 工作池模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func worker(id int, jobs \u0026lt;-chan int, results chan\u0026lt;- int) { for j := range jobs { fmt.Printf(\u0026#34;worker %d 开始处理任务 %d\\n\u0026#34;, id, j) time.Sleep(time.Second) results \u0026lt;- j * 2 fmt.Printf(\u0026#34;worker %d 完成任务 %d\\n\u0026#34;, id, j) } } func main() { jobs := make(chan int, 100) results := make(chan int, 100) // 启动工作池 for w := 1; w \u0026lt;= 3; w++ { go worker(w, jobs, results) } // 发送任务 for j := 1; j \u0026lt;= 9; j++ { jobs \u0026lt;- j } close(jobs) // 收集结果 for a := 1; a \u0026lt;= 9; a++ { fmt.Println(\u0026lt;-results) } } 发布订阅模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 type PubSub struct { mu sync.RWMutex subs map[string][]chan string } func NewPubSub() *PubSub { return \u0026amp;PubSub{ subs: make(map[string][]chan string), } } func (ps *PubSub) Subscribe(topic string) chan string { ps.mu.Lock() defer ps.mu.Unlock() ch := make(chan string) ps.subs[topic] = append(ps.subs[topic], ch) return ch } func (ps *PubSub) Publish(topic string, msg string) { ps.mu.RLock() defer ps.mu.RUnlock() for _, ch := range ps.subs[topic] { go func(ch chan string) { ch \u0026lt;- msg }(ch) } } 并发安全 原子操作 1 2 3 4 5 6 7 8 9 var counter int64 func increment() { atomic.AddInt64(\u0026amp;counter, 1) } func getCounter() int64 { return atomic.LoadInt64(\u0026amp;counter) } 并发安全的 Map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var syncMap sync.Map // 存储键值对 syncMap.Store(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) // 加载值 value, ok := syncMap.Load(\u0026#34;key\u0026#34;) // 删除键值对 syncMap.Delete(\u0026#34;key\u0026#34;) // 遍历 syncMap.Range(func(key, value interface{}) bool { fmt.Printf(\u0026#34;%v: %v\\n\u0026#34;, key, value) return true }) 参考资源 Go 并发编程 Go sync 包文档 Go atomic 包文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/8.-go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","title":"8. Go 并发编程"},{"content":"HTTP 客户端 基本请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // GET 请求 resp, err := http.Get(\u0026#34;https://api.example.com/data\u0026#34;) if err != nil { log.Fatal(err) } defer resp.Body.Close() // 读取响应 body, err := io.ReadAll(resp.Body) if err != nil { log.Fatal(err) } fmt.Println(string(body)) // POST 请求 data := []byte(`{\u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;}`) resp, err = http.Post(\u0026#34;https://api.example.com/create\u0026#34;, \u0026#34;application/json\u0026#34;, bytes.NewBuffer(data)) if err != nil { log.Fatal(err) } defer resp.Body.Close() 自定义请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 创建请求 req, err := http.NewRequest(\u0026#34;POST\u0026#34;, \u0026#34;https://api.example.com/data\u0026#34;, bytes.NewBuffer(data)) if err != nil { log.Fatal(err) } // 设置请求头 req.Header.Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) req.Header.Set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer token\u0026#34;) // 发送请求 client := \u0026amp;http.Client{} resp, err := client.Do(req) if err != nil { log.Fatal(err) } defer resp.Body.Close() HTTP 服务器 基本服务器 1 2 3 4 5 6 7 8 func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello, %s!\u0026#34;, r.URL.Path[1:]) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } 路由处理 1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;首页\u0026#34;) }) mux.HandleFunc(\u0026#34;/api\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;API 页面\u0026#34;) }) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, mux)) } 中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func loggingMiddleware(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { start := time.Now() next.ServeHTTP(w, r) log.Printf(\u0026#34;%s %s %v\u0026#34;, r.Method, r.URL.Path, time.Since(start)) }) } func main() { mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, handler) // 使用中间件 handler := loggingMiddleware(mux) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, handler)) } WebSocket WebSocket 服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 var upgrader = websocket.Upgrader{ ReadBufferSize: 1024, WriteBufferSize: 1024, CheckOrigin: func(r *http.Request) bool { return true // 允许所有来源 }, } func handleWebSocket(w http.ResponseWriter, r *http.Request) { conn, err := upgrader.Upgrade(w, r, nil) if err != nil { log.Println(err) return } defer conn.Close() for { messageType, message, err := conn.ReadMessage() if err != nil { log.Println(err) break } // 发送响应 err = conn.WriteMessage(messageType, message) if err != nil { log.Println(err) break } } } func main() { http.HandleFunc(\u0026#34;/ws\u0026#34;, handleWebSocket) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } WebSocket 客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { conn, _, err := websocket.DefaultDialer.Dial(\u0026#34;ws://localhost:8080/ws\u0026#34;, nil) if err != nil { log.Fatal(err) } defer conn.Close() // 发送消息 err = conn.WriteMessage(websocket.TextMessage, []byte(\u0026#34;Hello!\u0026#34;)) if err != nil { log.Fatal(err) } // 接收消息 _, message, err := conn.ReadMessage() if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;收到消息: %s\\n\u0026#34;, message) } TCP 服务器 TCP 服务器示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 func handleConnection(conn net.Conn) { defer conn.Close() buffer := make([]byte, 1024) for { n, err := conn.Read(buffer) if err != nil { log.Println(err) return } // 发送响应 _, err = conn.Write(buffer[:n]) if err != nil { log.Println(err) return } } } func main() { listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8080\u0026#34;) if err != nil { log.Fatal(err) } defer listener.Close() for { conn, err := listener.Accept() if err != nil { log.Println(err) continue } go handleConnection(conn) } } TCP 客户端示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:8080\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() // 发送数据 _, err = conn.Write([]byte(\u0026#34;Hello, Server!\u0026#34;)) if err != nil { log.Fatal(err) } // 接收响应 buffer := make([]byte, 1024) n, err := conn.Read(buffer) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;收到响应: %s\\n\u0026#34;, buffer[:n]) } 参考资源 Go net 包文档 Go net/http 包文档 Go gorilla/websocket 包文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/9.-go-%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C/","title":"9. Go 网络操作"},{"content":"flag 包简介 flag 包是 Go 标准库中用于解析命令行参数的包。它提供了简单而强大的命令行参数处理功能。\n基本用法 定义参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) // 定义命令行参数 var ( name = flag.String(\u0026#34;name\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;用户名称\u0026#34;) age = flag.Int(\u0026#34;age\u0026#34;, 0, \u0026#34;用户年龄\u0026#34;) verbose = flag.Bool(\u0026#34;v\u0026#34;, false, \u0026#34;是否显示详细信息\u0026#34;) ) func main() { // 解析命令行参数 flag.Parse() // 使用参数 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, *name) fmt.Printf(\u0026#34;Age: %d\\n\u0026#34;, *age) fmt.Printf(\u0026#34;Verbose: %v\\n\u0026#34;, *verbose) } 运行示例 1 2 3 4 5 6 7 8 # 使用默认值 go run main.go # 指定参数 go run main.go -name \u0026#34;John\u0026#34; -age 25 -v # 查看帮助信息 go run main.go -help 高级用法 自定义参数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 自定义时间类型 type timeValue time.Time func (t *timeValue) String() string { return time.Time(*t).Format(time.RFC3339) } func (t *timeValue) Set(value string) error { parsed, err := time.Parse(time.RFC3339, value) if err != nil { return err } *t = timeValue(parsed) return nil } func main() { var t timeValue flag.Var(\u0026amp;t, \u0026#34;time\u0026#34;, \u0026#34;设置时间 (RFC3339格式)\u0026#34;) flag.Parse() fmt.Printf(\u0026#34;Time: %v\\n\u0026#34;, time.Time(t)) } 子命令支持 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 创建子命令 addCmd := flag.NewFlagSet(\u0026#34;add\u0026#34;, flag.ExitOnError) listCmd := flag.NewFlagSet(\u0026#34;list\u0026#34;, flag.ExitOnError) // 定义子命令参数 addName := addCmd.String(\u0026#34;name\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;添加项目名称\u0026#34;) listAll := listCmd.Bool(\u0026#34;all\u0026#34;, false, \u0026#34;列出所有项目\u0026#34;) // 检查子命令 if len(os.Args) \u0026lt; 2 { fmt.Println(\u0026#34;需要指定子命令: add 或 list\u0026#34;) os.Exit(1) } switch os.Args[1] { case \u0026#34;add\u0026#34;: addCmd.Parse(os.Args[2:]) fmt.Printf(\u0026#34;添加项目: %s\\n\u0026#34;, *addName) case \u0026#34;list\u0026#34;: listCmd.Parse(os.Args[2:]) fmt.Printf(\u0026#34;列出所有项目: %v\\n\u0026#34;, *listAll) default: fmt.Println(\u0026#34;未知的子命令\u0026#34;) os.Exit(1) } } 常用函数 flag.String(): 定义字符串参数 flag.Int(): 定义整数参数 flag.Bool(): 定义布尔参数 flag.Float64(): 定义浮点数参数 flag.Duration(): 定义时间间隔参数 flag.Var(): 定义自定义类型参数 flag.Parse(): 解析命令行参数 flag.Usage(): 显示帮助信息 参考资源 Go flag 包文档 Go 命令行参数处理 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/go-flag-%E5%8C%85%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Go flag 包使用指南"},{"content":"控制台输入方法 Go 语言提供了多种处理控制台输入的方法，每种方法都有其特点和适用场景。\n1. fmt.Scan 系列 fmt.Scan 系列函数是最简单的输入方法，适合简单的输入场景。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; func main() { var name string var age int // 读取字符串 fmt.Print(\u0026#34;请输入姓名: \u0026#34;) fmt.Scan(\u0026amp;name) // 读取整数 fmt.Print(\u0026#34;请输入年龄: \u0026#34;) fmt.Scan(\u0026amp;age) fmt.Printf(\u0026#34;姓名: %s, 年龄: %d\\n\u0026#34;, name, age) } 2. bufio.Scanner bufio.Scanner 提供了更灵活的输入处理方式，适合处理多行输入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { scanner := bufio.NewScanner(os.Stdin) // 读取一行 fmt.Print(\u0026#34;请输入姓名: \u0026#34;) scanner.Scan() name := scanner.Text() // 读取整数 fmt.Print(\u0026#34;请输入年龄: \u0026#34;) scanner.Scan() age, _ := strconv.Atoi(scanner.Text()) fmt.Printf(\u0026#34;姓名: %s, 年龄: %d\\n\u0026#34;, name, age) } 3. bufio.Reader bufio.Reader 提供了底层的输入控制，适合需要精确控制输入的场景。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func main() { reader := bufio.NewReader(os.Stdin) // 读取一行（包含换行符） fmt.Print(\u0026#34;请输入姓名: \u0026#34;) name, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) name = strings.TrimSpace(name) // 读取单个字符 fmt.Print(\u0026#34;请输入性别 (M/F): \u0026#34;) gender, _ := reader.ReadByte() fmt.Printf(\u0026#34;姓名: %s, 性别: %c\\n\u0026#34;, name, gender) } 4. io.ReadAll io.ReadAll 用于一次性读取所有输入，适合处理完整的输入流。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 读取所有输入直到 EOF input, _ := io.ReadAll(os.Stdin) fmt.Printf(\u0026#34;输入内容:\\n%s\u0026#34;, input) } 使用建议 简单输入\n使用 fmt.Scan 系列函数 适合基本的用户输入 多行输入\n使用 bufio.Scanner 适合处理文本文件或复杂输入 精确控制\n使用 bufio.Reader 适合需要特殊输入处理的场景 完整输入流\n使用 io.ReadAll 适合处理管道或重定向输入 参考资源 Go fmt 包文档 Go bufio 包文档 Go io 包文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/go-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5%E5%A4%84%E7%90%86/","title":"Go 控制台输入处理"},{"content":"命令行参数简介 在 Go 中，可以通过 os.Args 获取命令行参数。os.Args 是一个字符串切片，其中：\nos.Args[0] 是程序名称 os.Args[1:] 包含所有命令行参数 基本用法 获取所有参数 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 遍历所有参数 for i, arg := range os.Args { fmt.Printf(\u0026#34;参数 %d: %s\\n\u0026#34;, i, arg) } } 运行示例 1 2 3 4 5 6 7 8 # 运行程序 go run main.go arg1 arg2 arg3 # 输出结果 参数 0: /tmp/go-build123456789/b001/exe/main 参数 1: arg1 参数 2: arg2 参数 3: arg3 参数处理 参数解析示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { // 检查参数数量 if len(os.Args) \u0026lt; 2 { fmt.Println(\u0026#34;请提供至少一个参数\u0026#34;) os.Exit(1) } // 处理不同类型的参数 for i := 1; i \u0026lt; len(os.Args); i++ { arg := os.Args[i] // 尝试转换为整数 if num, err := strconv.Atoi(arg); err == nil { fmt.Printf(\u0026#34;数字参数: %d\\n\u0026#34;, num) } else { fmt.Printf(\u0026#34;字符串参数: %s\\n\u0026#34;, arg) } } } 参数验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func main() { // 参数验证示例 if len(os.Args) != 3 { fmt.Println(\u0026#34;用法: program \u0026lt;命令\u0026gt; \u0026lt;参数\u0026gt;\u0026#34;) os.Exit(1) } command := os.Args[1] value := os.Args[2] // 命令验证 switch command { case \u0026#34;add\u0026#34;: fmt.Printf(\u0026#34;添加: %s\\n\u0026#34;, value) case \u0026#34;remove\u0026#34;: fmt.Printf(\u0026#34;删除: %s\\n\u0026#34;, value) default: fmt.Printf(\u0026#34;未知命令: %s\\n\u0026#34;, command) os.Exit(1) } // 参数验证 if strings.TrimSpace(value) == \u0026#34;\u0026#34; { fmt.Println(\u0026#34;参数不能为空\u0026#34;) os.Exit(1) } } 参考资源 Go os 包文档 Go 命令行参数处理 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/go-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/","title":"Go 命令行参数处理"},{"content":"运行 Go 文件 使用 go run 命令可以直接运行 Go 源文件，无需手动编译。这个命令会临时编译并运行指定的文件。\n1 2 3 4 5 6 7 8 # 运行单个文件 go run hello.go # 运行多个文件 go run main.go utils.go # 运行当前目录下的所有 Go 文件 go run . 编译 Go 文件 使用 go build 命令可以编译 Go 源文件，生成可执行文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 编译单个文件 go build hello.go # 编译整个项目 go build # 指定输出文件名 go build -o myapp hello.go # 跨平台编译 # Windows GOOS=windows GOARCH=amd64 go build -o app.exe # Linux GOOS=linux GOARCH=amd64 go build -o app # macOS GOOS=darwin GOARCH=amd64 go build -o app 编译选项 -o：指定输出文件名 -v：显示编译的包名 -x：显示编译命令 -race：启用竞态检测 -ldflags：设置链接参数 运行编译后的程序 编译完成后，可以直接运行生成的可执行文件：\n1 2 3 4 5 # Windows hello.exe # Linux/macOS ./hello 参考资源 Go 命令行文档 Go 构建文档 ","date":"2025-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/go-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C%E5%92%8C%E7%BC%96%E8%AF%91/","title":"Go 命令行运行和编译"},{"content":"概述 微信小游戏试玩是一种特殊的游戏体验方式，允许用户在正式下载游戏之前先体验游戏内容。本文将介绍两种在 Cocos Creator 中导出微信小游戏试玩的方法，以及可能遇到的问题和解决方案。\n导出方式 1. 传统方式（使用 adapter） 前置准备 下载官方 demo 工程：wechat-miniprogram/minigame-playable 准备试玩小程序的 AppID 构建步骤 准备构建模板\n将 build-templates 文件夹复制到试玩工程目录下 配置小程序信息\n在项目设置中配置试玩小程序的 AppID 构建小程序\n在 Cocos Creator 中选择\u0026quot;构建微信小游戏\u0026quot; 确保选择正确的构建模板 整合到主游戏\n将构建的小程序工程复制到主游戏的 playableDemo 文件夹下 配置分包信息\n修改主工程的 game.json，添加试玩分包配置： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026#34;subPackages\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;moduleA\u0026#34;, \u0026#34;root\u0026#34;: \u0026#34;/moduleA/\u0026#34; // 普通分包 }, { \u0026#34;independent\u0026#34;: true, \u0026#34;name\u0026#34;: \u0026#34;playableDemo\u0026#34;, \u0026#34;root\u0026#34;: \u0026#34;/playableDemo/\u0026#34;, \u0026#34;meta\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;playable\u0026#34;, \u0026#34;playableOrientation\u0026#34;: \u0026#34;portrait\u0026#34; } } ] 构建分包\n新建分包构建配置 选择\u0026quot;分包构建\u0026quot;模式 执行构建 常见问题 资源文件缺失\n问题：编译时提示 logo.png 和 slogan.png 缺失 解决：复制或创建所需的图片资源文件 引擎裁剪问题\n问题：TypeError: Cannot read property 'passes' of undefined 解决：在 Cocos Creator 中修改引擎裁剪设置 打开 Project Settings 选择 Feature Cropping 在 2D 选项中勾选： User Interface Tiled Map 音频加载失败\n问题：cc.js:88919 failed to load innerAudioContext 解决：由于 adapter 方式的限制，建议使用新的构建方式 2. 新构建方式（推荐） 构建步骤 配置小程序信息\n在项目设置中配置试玩小程序的 AppID 构建微信小游戏\n选择\u0026quot;构建微信小游戏\u0026quot; 使用默认构建配置 导入开发工具\n在微信开发者工具中导入构建结果 工具会自动识别为试玩版本 编译上传\n执行编译 上传到微信平台 优势 构建流程更简单 更好的兼容性 更少的配置步骤 更稳定的运行效果 注意事项 资源限制\n注意试玩包大小限制 合理规划资源加载 避免资源浪费 功能限制\n了解试玩版本的功能限制 避免使用不支持的特性 做好功能降级处理 兼容性\n测试不同设备 验证各种场景 处理异常情况 参考资源 微信小游戏试玩文档 Cocos Creator 文档 微信小游戏开发文档 ","date":"2025-03-06T10:41:48+08:00","permalink":"https://imhy.top/p/cocos-creator-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E8%AF%95%E7%8E%A9%E5%AF%BC%E5%87%BA%E6%8C%87%E5%8D%97/","title":"Cocos Creator 微信小游戏试玩导出指南"},{"content":"开发环境 Unity 2022.3.46f1 Rider 2024.3.33 .NET 6.0.201 Obfuscar 2.2.40 问题背景 为了防代码泄露，需要隔离开发工程和美术工程，将开发工程代码编译成 DLL，并且混淆后导入美术工程使用。\n遇到了一个错误：混淆后的 DLL 在 Unity 中报错 Unable to resolve reference 'System.Private.CoreLib'，而未混淆的 DLL 没有这个问题。\n问题现象 正常情况\n未混淆的 Dave.CodeGen.dll 在 Unity 中正常运行 使用 ILSpy 检查发现引用的是 mscorlib 异常情况\n使用 Obfuscar.Console 混淆后，Unity 报错： 1 Unable to resolve reference \u0026#39;System.Private.CoreLib\u0026#39;. Is the assembly missing or incompatible with the current platform 使用 ILSpy 检查发现引用了 System.Private.CoreLib 问题分析 1. 初步猜测 System.Private.CoreLib 是 .NET Core / .NET 5+ 的核心库 Unity 使用的是 .NET Framework 4.8（基于 mscorlib） 混淆过程可能引入了不兼容的引用 2. 排查过程 检查 .NET 版本 操作步骤\n使用 ILSpy 打开混淆后的 Dave.CodeGen.dll 发现\n目标框架是 .NET Framework 4.7.2，与预期一致 引用中出现了 System.Private.CoreLib 结论\n.NET 版本正确，问题不在目标框架 对比未混淆的 DLL 操作步骤\n用 ILSpy 打开未混淆的 Dave.CodeGen.dll 发现\n未混淆的 DLL 引用的是 mscorlib 没有 System.Private.CoreLib 引用 结论\n混淆过程引入了 System.Private.CoreLib 的引用 环境检查 .NET 环境\n1 2 3 4 5 6 # 检查 SDK 版本 dotnet --list-sdks dotnet --version # 检查运行时版本 dotnet --info Unity 编译\nUnity 自动编译 Unity 命令行编译 输出位置：Library/ScriptAssemblies/ Obfuscar 工具\n1 2 3 4 5 # 安装 dotnet tool install --global Obfuscar.GlobalTool --version 2.2.40 # 卸载 dotnet tool uninstall --global Obfuscar.GlobalTool 解决方案 1. 调整混淆配置 在 Obfuscar 配置文件中添加 mscorlib.dll 的路径（./obfuscar_dependencies/mscorlib.dll）：\n1 \u0026lt;AssemblySearchPath path=\u0026#34;./obfuscar_dependencies\u0026#34; /\u0026gt; 2. 配置步骤 创建依赖目录\n在项目目录下创建 obfuscar_dependencies 文件夹 将 mscorlib.dll 复制到该目录 验证配置\n混淆后的 DLL 引用 mscorlib 无 System.Private.CoreLib 引用 在 Unity 中运行正常 问题根源 原因分析 Obfuscar 在混淆时未找到 mscorlib.dll，可能从系统路径（.NET 6 SDK）加载了 System.Private.CoreLib。这是因为：\nObfuscar 默认会搜索系统路径 系统中安装了 .NET 6 SDK 没有明确指定 mscorlib.dll 的路径 ","date":"2025-03-05T16:03:30+08:00","permalink":"https://imhy.top/p/unity-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84-system.private.corelib-%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/","title":"Unity 项目中的 System.Private.CoreLib 引用问题"},{"content":"基础数据类型 TypeScript 支持 JavaScript 的所有基础数据类型，并添加了类型注解。以下是主要的基础数据类型：\n1. number 类型 表示数字类型，包括整数和浮点数：\n1 2 3 4 5 6 let decimal: number = 6; // 十进制 let hex: number = 0xf00d; // 十六进制 let binary: number = 0b1010; // 二进制 let octal: number = 0o744; // 八进制 let float: number = 3.14; // 浮点数 let scientific: number = 3.14e2; // 科学计数法 2. bigint 类型 表示大整数，可以安全地存储和操作大整数：\n1 2 3 4 5 6 let bigInt: bigint = 9007199254740991n; let bigInt2: bigint = BigInt(9007199254740991); // 注意：bigint 不能与 number 直接运算 let result: bigint = bigInt + 1n; // 正确 let error: bigint = bigInt + 1; // 错误 3. string 类型 表示字符串，支持单引号、双引号和模板字符串：\n1 2 3 4 5 6 7 let name: string = \u0026#34;TypeScript\u0026#34;; let message: string = \u0026#39;Hello World\u0026#39;; let template: string = `Hello ${name}`; let multiline: string = ` This is a multiline string `; 4. boolean 类型 表示布尔值，只有 true 和 false 两个值：\n1 2 let isDone: boolean = false; let isActive: boolean = true; 5. symbol 类型 表示唯一的标识符，通常用于对象属性的键：\n1 2 3 4 5 let sym1: symbol = Symbol(); let sym2: symbol = Symbol(\u0026#34;key\u0026#34;); // 可选的字符串键 // 注意：每个 Symbol 都是唯一的 console.log(sym1 === sym2); // false 6. null 和 undefined 类型 表示空值：\n1 2 3 4 5 6 let u: undefined = undefined; let n: null = null; // 注意：null 和 undefined 是所有类型的子类型 let num: number = undefined; // 正确 let str: string = null; // 正确 7. void 类型 表示没有任何类型，通常用于函数返回值：\n1 2 3 4 5 6 function warnUser(): void { console.log(\u0026#34;This is a warning message\u0026#34;); } // 注意：声明 void 类型的变量只能赋值 undefined 或 null let unusable: void = undefined; 8. object 类型 表示非原始类型，即除 number、string、boolean、symbol、null 或 undefined 之外的类型：\n1 2 3 4 5 6 let obj: object = { name: \u0026#34;TypeScript\u0026#34; }; let arr: object = [1, 2, 3]; let func: object = function() {}; // 注意：object 类型不包含原始类型 let primitive: object = 42; // 错误 类型推断 TypeScript 可以根据上下文自动推断类型：\n1 2 3 4 5 6 7 8 9 10 11 // 类型推断为 number let x = 3; // 类型推断为 string let y = \u0026#34;hello\u0026#34;; // 类型推断为 boolean let z = true; // 类型推断为 number[] let numbers = [1, 2, 3]; 类型注解 可以显式声明变量类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 基本类型注解 let name: string = \u0026#34;TypeScript\u0026#34;; let age: number = 25; let isStudent: boolean = true; // 数组类型注解 let numbers: number[] = [1, 2, 3]; let strings: string[] = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; // 元组类型注解 let tuple: [string, number] = [\u0026#34;hello\u0026#34;, 10]; // 枚举类型注解 enum Color { Red, Green, Blue } let favoriteColor: Color = Color.Blue; 类型断言 允许你覆盖 TypeScript 的类型推断：\n1 2 3 4 5 6 7 // 尖括号语法 let someValue: any = \u0026#34;this is a string\u0026#34;; let strLength: number = (\u0026lt;string\u0026gt;someValue).length; // as 语法 let someValue2: any = \u0026#34;this is a string\u0026#34;; let strLength2: number = (someValue2 as string).length; 最佳实践 优先使用类型推断\n让 TypeScript 自动推断类型 只在必要时添加类型注解 避免使用 any\n优先使用具体的类型 如果必须使用，添加注释说明原因 合理使用类型断言\n只在确信类型正确时使用 优先使用 as 语法而不是尖括号 注意 null 和 undefined\n使用可选链操作符 ?. 使用空值合并操作符 ?? 总结 类型 描述 示例 注意事项 number 数字类型 let num: number = 42 支持整数和浮点数 bigint 大整数 let big: bigint = 9007199254740991n 不能与 number 直接运算 string 字符串 let str: string = \u0026quot;hello\u0026quot; 支持模板字符串 boolean 布尔值 let bool: boolean = true 只有 true/false symbol 唯一标识符 let sym: symbol = Symbol() 每个值都是唯一的 null 空值 let n: null = null 所有类型的子类型 undefined 未定义 let u: undefined = undefined 所有类型的子类型 void 无类型 function f(): void {} 只能赋值 undefined object 非原始类型 let obj: object = {} 不包含原始类型 记住：\n优先使用类型推断 只在必要时添加类型注解 避免使用 any 类型 合理使用类型断言 ","date":"2024-08-23T14:17:35+08:00","permalink":"https://imhy.top/p/typescript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/","title":"TypeScript 数据类型详解"},{"content":"概述 在 Unity 开发微信小游戏时，打开游戏圈和获取用户信息是两个常用的功能。本文将详细介绍这两个功能的实现方法，以及在开发过程中可能遇到的问题和解决方案。\n打开游戏圈 基本实现 创建打开游戏圈的按钮，点击后跳转到微信游戏圈：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var btn = WXBase.CreateGameClubButton(new WXCreateGameClubButtonParam() { type = GameClubButtonType.image, icon = GameClubButtonIcon.light, openlink = url, style = new GameClubButtonStyle() { left = left, top = top, width = w, height = h } }); 按钮样式说明 type：按钮类型 image：图片按钮 text：文字按钮 icon：按钮图标 light：浅色图标 dark：深色图标 style：按钮样式 left：左边距 top：上边距 width：宽度 height：高度 获取用户信息 1. 检查授权状态 在获取用户信息之前，需要先检查用户是否已授权：\n1 2 3 4 5 6 7 8 9 10 WX.GetSetting(new GetSettingOption() { success = (res) =\u0026gt; { var isAuth = res != null \u0026amp;\u0026amp; res.authSetting.ContainsKey(\u0026#34;scope.userInfo\u0026#34;) \u0026amp;\u0026amp; res.authSetting[\u0026#34;scope.userInfo\u0026#34;]; callback.Invoke(isAuth); } }); 2. 获取用户信息 如果用户已授权，可以直接获取用户信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 WX.GetUserInfo(new GetUserInfoOption() { success = (res) =\u0026gt; { if (res == null || res.userInfo == null) { callback.Invoke(null, null); return; } var name = res.userInfo.nickName; var avatar = res.userInfo.avatarUrl; callback.Invoke(name, avatar); }, fail = (res) =\u0026gt; { callback.Invoke(null, null); } }); 3. 创建授权按钮 如果用户未授权，需要创建授权按钮：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var btn = WXBase.CreateUserInfoButton(left, top, w, h, \u0026#34;zh_CN\u0026#34;, false); btn.OnTap((res) =\u0026gt; { // 拒绝授权 if (res.errCode != 0) { callback.Invoke(null, null); return; } callback.Invoke(res.userInfo.nickName, res.userInfo.avatarUrl); btn.Hide(); }); 调试技巧 在微信开发者工具中，可以通过鼠标指针变化来识别授权按钮的位置：\n当鼠标移动到授权按钮区域时，指针会从圈变成箭头 这个特性可以帮助开发者准确定位按钮位置 分辨率问题 分辨率类型 物理分辨率\n设备实际的像素点数 例如：iPhone 14 Pro Max 为 1290*2796 通过 Screen.width 和 Screen.height 获取 逻辑分辨率\n用于界面适配的抽象概念 例如：iPhone 14 Pro Max 为 430*932 通过 GetSystemInfoOption 获取 按钮位置计算 不同按钮使用不同的分辨率系统：\n游戏圈按钮\n使用逻辑分辨率 获取方式： 1 2 3 4 5 6 7 8 9 WX.GetSystemInfo(new GetSystemInfoOption() { success = (info) =\u0026gt; { var dpr = info.pixelRatio; var width = info.screenWidth; var height = info.screenHeight; } }); 授权按钮\n使用物理分辨率 获取方式： 1 2 var width = Screen.width; var height = Screen.height; 分辨率转换 DPR（Device Pixel Ratio）= 物理分辨率 / 逻辑分辨率 例如：iPhone 14 Pro Max 的 DPR = 3 常见问题 按钮位置不准确\n检查是否使用了正确的分辨率系统 验证坐标计算是否正确 考虑设备适配问题 授权失败\n检查网络连接 验证用户是否拒绝授权 确认微信版本是否支持 按钮显示异常\n检查按钮样式设置 验证按钮大小是否合适 确认按钮层级是否正确 参考资源 微信小游戏开发文档 微信小游戏用户信息接口 微信小游戏游戏圈接口 ","date":"2024-08-23T09:59:22+08:00","permalink":"https://imhy.top/p/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%89%93%E5%BC%80%E6%B8%B8%E6%88%8F%E5%9C%88%E5%92%8C%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/","title":"微信小游戏：打开游戏圈和获取用户信息"},{"content":"类型系统概述 在 TypeScript 的类型系统中，any、unknown 和 never 是三个特殊的类型，它们各自具有独特的特性和使用场景。从集合论的角度来看：\nany 和 unknown 是顶层类型（top type），可以包含所有其他类型 never 是底层类型（bottom type），不包含任何值 any 类型 基本特性 any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。从集合论的角度看，any 类型是所有其他类型的全集。\n1 2 3 4 5 6 7 let x: any; x = 1; // 正确 x = \u0026#34;hello\u0026#34;; // 正确 x = false; // 正确 x = []; // 正确 x = {}; // 正确 类型检查关闭 当变量类型设为 any 时，TypeScript 会关闭该变量的类型检查：\n1 2 3 4 5 let x: any = \u0026#39;hello\u0026#39;; x(1) // 不报错 x.foo = 100; // 不报错 x.bar(); // 不报错 类型污染 any 类型存在污染问题，可以赋值给其他任何类型：\n1 2 3 4 5 6 let x: any = \u0026#39;hello\u0026#39;; let y: number; y = x; // 不报错 y * 123; // 不报错 y.toFixed(); // 不报错 使用场景 特殊情况下关闭类型检查\n1 2 // 处理第三方库的类型问题 const thirdPartyLib: any = require(\u0026#39;some-library\u0026#39;); JavaScript 项目迁移\n1 2 // 迁移旧项目时临时使用 const legacyData: any = getLegacyData(); 动态数据处理\n1 2 // 处理动态 API 响应 const response: any = await fetchData(); unknown 类型 基本特性 unknown 是 TypeScript 3.0 引入的类型，可以视为严格版的 any。它表示类型不确定，可能是任意类型，但使用上有严格限制。\n1 2 3 4 5 let x: unknown; x = true; // 正确 x = 42; // 正确 x = \u0026#39;Hello\u0026#39;; // 正确 使用限制 不能赋值给其他类型\n1 2 3 4 5 let v: unknown = 123; let v1: boolean = v; // 报错 let v2: number = v; // 报错 let v3: string = v; // 报错 不能直接访问属性和方法\n1 2 3 4 5 6 7 8 let v1: unknown = { foo: 123 }; v1.foo; // 报错 let v2: unknown = \u0026#39;hello\u0026#39;; v2.trim(); // 报错 let v3: unknown = (n = 0) =\u0026gt; n + 1; v3(); // 报错 允许的操作 unknown 类型变量只能进行以下操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let a: unknown = 1; // 允许的操作 a === 1; // 比较运算 a !== 1; // 比较运算 !a; // 取反运算 a \u0026amp;\u0026amp; b; // 逻辑运算 a || b; // 逻辑运算 a ? b : c; // 条件运算 typeof a; // typeof 运算符 a instanceof Date; // instanceof 运算符 // 不允许的操作 a + 1; // 报错 a.toString(); // 报错 类型收窄 使用类型收窄后，可以安全地使用 unknown 类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 function processValue(value: unknown) { if (typeof value === \u0026#39;string\u0026#39;) { console.log(value.toUpperCase()); // 正确 } if (value instanceof Date) { console.log(value.getTime()); // 正确 } if (Array.isArray(value)) { console.log(value.length); // 正确 } } never 类型 基本特性 never 类型表示永远不会发生的类型，不包含任何值。从集合论的角度看，它是空集。\n1 2 let x: never; // 正确 let a: never = 1; // 报错 使用场景 永不返回的函数\n1 2 3 function throwError(): never { throw new Error(\u0026#39;Error\u0026#39;); } 穷尽性检查\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Shape = \u0026#39;circle\u0026#39; | \u0026#39;square\u0026#39;; function getArea(shape: Shape): number { switch (shape) { case \u0026#39;circle\u0026#39;: return Math.PI * radius * radius; case \u0026#39;square\u0026#39;: return side * side; default: const _exhaustiveCheck: never = shape; return _exhaustiveCheck; } } 类型收窄\n1 2 3 4 5 6 7 8 9 function processValue(value: string | number) { if (typeof value === \u0026#39;string\u0026#39;) { // value 被收窄为 string 类型 } else if (typeof value === \u0026#39;number\u0026#39;) { // value 被收窄为 number 类型 } else { // value 被收窄为 never 类型 } } 最佳实践 避免使用 any\n优先使用具体的类型 如果必须使用，添加 // @ts-ignore 注释说明原因 使用 unknown 替代 any\n处理外部数据时使用 unknown 通过类型收窄安全地使用 合理使用 never\n用于表示不可能的情况 帮助 TypeScript 进行穷尽性检查 总结 类型 描述 特点 使用场景 any 任意类型 关闭类型检查，可污染其他类型 旧项目迁移，第三方库集成 unknown 未知类型 类型安全，需要类型收窄 处理外部数据，API 响应 never 空类型 不包含任何值 穷尽性检查，永不返回的函数 记住：\nany 和 unknown 是顶层类型，可以承接任何类型 never 是底层类型，可以赋值给任何类型 优先使用 unknown 而不是 any 使用 never 进行穷尽性检查 ","date":"2024-08-21T15:27:36+08:00","permalink":"https://imhy.top/p/typescript-%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8Banyunknown-%E5%92%8C-never/","title":"TypeScript 特殊类型：any、unknown 和 never"},{"content":"Git 基础配置 1. 全局配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 配置用户信息 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;your.email@example.com\u0026#34; # 配置默认编辑器 git config --global core.editor \u0026#34;code --wait\u0026#34; # 配置默认分支名 git config --global init.defaultBranch main # 配置行尾处理 git config --global core.autocrlf false # 说明： # - true：提交时转换为LF，检出时转换为CRLF（Windows推荐） # - false：不进行自动转换（跨平台开发推荐） # - input：提交时转换为LF，检出时不转换（Linux/Mac推荐） # 配置中文显示 git config --global core.quotepath false 2. 常用别名配置 1 2 3 4 5 # 配置常用命令别名 git config --global alias.st status git config --global alias.br branch git config --global alias.ci commit git config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit\u0026#34; Git 新特性 Git 2.23 及以后版本 版本 新特性 说明 2.23 git switch 简化分支切换操作，替代部分 git checkout 功能 2.23 git restore 恢复文件状态的新命令，替代部分 git checkout 和 git reset 功能 2.24 git sparse-checkout 允许只检出仓库部分内容，节省空间 2.25 git switch/restore 增强 改进功能和稳定性 2.26 git restore --source 允许指定恢复内容的源 2.27 git commit --verbose 提交时显示详细变更信息 2.28 git config includeIf 支持条件性包含配置文件 2.29 git diff --inter-hunk-context 增强 diff 上下文显示 2.30 git commit --no-verify 跳过钩子验证的提交选项 2.31 git switch --orphan 创建新的孤立分支 2.32 git commit --dry-run 预查看提交内容 2.33 git branch --show-current 显示当前分支的简化命令 2.34 git rebase --exec 在变基操作后执行指定命令 常用操作 1. 仓库初始化 1 2 3 4 5 6 7 8 9 10 11 # 初始化新仓库 git init # 克隆远程仓库 git clone \u0026lt;repository_url\u0026gt; # 克隆特定分支 git clone -b \u0026lt;branch_name\u0026gt; \u0026lt;repository_url\u0026gt; # 浅克隆（只获取最新版本） git clone --depth 1 \u0026lt;repository_url\u0026gt; 2. 分支操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 创建并切换分支 git switch -c \u0026lt;branch_name\u0026gt; # 切换分支 git switch \u0026lt;branch_name\u0026gt; # 切换到上一个分支 git switch - # 创建新的孤立分支（不包含历史提交） git switch --orphan \u0026lt;branch_name\u0026gt; # 查看分支 git branch # 删除分支 git branch -d \u0026lt;branch_name\u0026gt; # 强制删除分支 git branch -D \u0026lt;branch_name\u0026gt; 3. 文件恢复 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 恢复工作区文件（丢弃未暂存的修改） git restore \u0026lt;file_name\u0026gt; # 恢复多个文件 git restore \u0026lt;file1\u0026gt; \u0026lt;file2\u0026gt; # 恢复所有未暂存的修改 git restore . # 从暂存区取消暂存（但保留工作区的修改） git restore --staged \u0026lt;file_name\u0026gt; # 从指定提交或分支恢复文件 git restore --source=HEAD~1 \u0026lt;file_name\u0026gt; # 从上一次提交恢复 git restore --source=main \u0026lt;file_name\u0026gt; # 从main分支恢复 # 恢复文件到特定版本 git restore --source=\u0026lt;commit_hash\u0026gt; \u0026lt;file_name\u0026gt; # 注意：如果文件同时存在于工作区和暂存区的修改 # --staged 和 --worktree 可以组合使用 git restore --staged --worktree \u0026lt;file_name\u0026gt; # 同时丢弃暂存区和工作区的修改 4. 提交操作 1 2 3 4 5 6 7 8 9 10 11 # 暂存文件 git add \u0026lt;file_name\u0026gt; # 暂存所有更改 git add . # 提交更改 git commit -m \u0026#34;commit message\u0026#34; # 修改最后一次提交 git commit --amend 5. 远程操作 1 2 3 4 5 6 7 8 9 10 11 # 添加远程仓库 git remote add \u0026lt;remote_name\u0026gt; \u0026lt;repository_url\u0026gt; # 推送到远程 git push \u0026lt;remote_name\u0026gt; \u0026lt;branch_name\u0026gt; # 拉取更新 git pull \u0026lt;remote_name\u0026gt; \u0026lt;branch_name\u0026gt; # 强制推送（谨慎使用） git push -f \u0026lt;remote_name\u0026gt; \u0026lt;branch_name\u0026gt; 高级操作 1. 覆盖所有提交 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 创建孤立分支 git checkout --orphan temp_branch # 添加所有文件 git add . # 提交更改 git commit -m \u0026#34;init\u0026#34; # 删除主分支 git branch -D main # 重命名分支 git branch -m temp_branch main # 强制推送到远程 git push -f origin main 注意：此操作不可撤销，请谨慎使用！\n2. 交互式变基 1 2 3 4 5 6 7 8 9 10 # 开始交互式变基 git rebase -i HEAD~3 # 修改最近3次提交 # 常用变基命令 # p, pick = 使用提交 # r, reword = 使用提交，但修改提交信息 # e, edit = 使用提交，但停止修改 # s, squash = 使用提交，但合并到前一个提交 # f, fixup = 类似 squash，但丢弃提交信息 # d, drop = 删除提交 3. 暂存操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 暂存当前更改 git stash # 暂存并添加描述 git stash push -m \u0026#34;stash message\u0026#34; # 查看暂存列表 git stash list # 应用暂存 git stash pop # 应用并删除 git stash apply # 应用但保留 # 删除暂存 git stash drop \u0026lt;stash_id\u0026gt; 常见问题 1. 中文显示问题 1 2 # 解决中文文件名显示问题 git config --global core.quotepath false 2. 大文件处理 1 2 3 4 # 使用 Git LFS 管理大文件 git lfs install git lfs track \u0026#34;*.psd\u0026#34; git lfs track \u0026#34;*.zip\u0026#34; 3. 凭证管理 1 2 3 # 配置凭证缓存 git config --global credential.helper cache git config --global credential.helper \u0026#39;cache --timeout=3600\u0026#39; 最佳实践 提交规范\n使用清晰的提交信息 遵循约定式提交规范 保持提交粒度适中 分支管理\n使用功能分支开发 定期合并主分支 及时删除无用分支 代码审查\n提交前自测 使用 Pull Request 进行代码审查 安全实践\n定期备份仓库 谨慎使用强制推送 保护敏感信息 ","date":"2024-08-20T16:39:37+08:00","permalink":"https://imhy.top/p/git-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Git 使用指南"},{"content":"基本I/O流 1. 标准输入输出流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; // 基本输出 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; 42 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 格式化输出 std::cout \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2); std::cout \u0026lt;\u0026lt; \u0026#34;Pi: \u0026#34; \u0026lt;\u0026lt; 3.14159265359 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 输出：3.14 std::cout \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::right \u0026lt;\u0026lt; \u0026#34;Right\u0026#34; \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::left \u0026lt;\u0026lt; \u0026#34;Left\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 基本输入 int n; std::cout \u0026lt;\u0026lt; \u0026#34;Enter a number: \u0026#34;; std::cin \u0026gt;\u0026gt; n; // 输入字符串 std::string name; std::cout \u0026lt;\u0026lt; \u0026#34;Enter your name: \u0026#34;; std::getline(std::cin, name); // 错误处理 if (std::cin.fail()) { std::cin.clear(); // 清除错误状态 std::cin.ignore(std::numeric_limits\u0026lt;std::streamsize\u0026gt;::max(), \u0026#39;\\n\u0026#39;); // 清空输入缓冲区 } 2. 流操纵算子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iomanip\u0026gt; // 数值格式 std::cout \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; 255 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 十六进制：ff std::cout \u0026lt;\u0026lt; std::oct \u0026lt;\u0026lt; 255 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 八进制：377 std::cout \u0026lt;\u0026lt; std::dec \u0026lt;\u0026lt; 255 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 十进制：255 // 浮点数格式 std::cout \u0026lt;\u0026lt; std::scientific \u0026lt;\u0026lt; 1234.5678 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 1.234568e+03 std::cout \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; 1234.5678 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 1234.567800 // 字段宽度和对齐 std::cout \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::right \u0026lt;\u0026lt; \u0026#34;Right\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::left \u0026lt;\u0026lt; \u0026#34;Left\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; std::setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; \u0026#34;Fill\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 布尔值格式 std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; true \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // true std::cout \u0026lt;\u0026lt; std::noboolalpha \u0026lt;\u0026lt; true \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 1 文件操作 1. 文本文件操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; // 写入文件 void writeTextFile() { std::ofstream outFile(\u0026#34;example.txt\u0026#34;); if (outFile.is_open()) { outFile \u0026lt;\u0026lt; \u0026#34;Hello, File I/O!\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; outFile \u0026lt;\u0026lt; 42 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; outFile.close(); } } // 读取文件 void readTextFile() { std::ifstream inFile(\u0026#34;example.txt\u0026#34;); if (inFile.is_open()) { std::string line; while (std::getline(inFile, line)) { std::cout \u0026lt;\u0026lt; line \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } inFile.close(); } } // 追加到文件 void appendToFile() { std::ofstream outFile(\u0026#34;example.txt\u0026#34;, std::ios::app); if (outFile.is_open()) { outFile \u0026lt;\u0026lt; \u0026#34;Appended text\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; outFile.close(); } } // 检查文件状态 void checkFileStatus() { std::ifstream file(\u0026#34;example.txt\u0026#34;); if (!file) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error opening file\\n\u0026#34;; return; } if (file.eof()) { std::cout \u0026lt;\u0026lt; \u0026#34;End of file reached\\n\u0026#34;; } if (file.bad()) { std::cout \u0026lt;\u0026lt; \u0026#34;Bad bit set (fatal error)\\n\u0026#34;; } if (file.fail()) { std::cout \u0026lt;\u0026lt; \u0026#34;Fail bit set (non-fatal error)\\n\u0026#34;; } } 2. 二进制文件操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;fstream\u0026gt; struct Record { int id; char name[50]; double score; }; // 写入二进制文件 void writeBinaryFile() { std::ofstream outFile(\u0026#34;data.bin\u0026#34;, std::ios::binary); if (outFile.is_open()) { Record record = {1, \u0026#34;John\u0026#34;, 95.5}; outFile.write(reinterpret_cast\u0026lt;char*\u0026gt;(\u0026amp;record), sizeof(Record)); outFile.close(); } } // 读取二进制文件 void readBinaryFile() { std::ifstream inFile(\u0026#34;data.bin\u0026#34;, std::ios::binary); if (inFile.is_open()) { Record record; inFile.read(reinterpret_cast\u0026lt;char*\u0026gt;(\u0026amp;record), sizeof(Record)); std::cout \u0026lt;\u0026lt; \u0026#34;ID: \u0026#34; \u0026lt;\u0026lt; record.id \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; record.name \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;Score: \u0026#34; \u0026lt;\u0026lt; record.score \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; inFile.close(); } } // 随机访问 void randomAccess() { std::fstream file(\u0026#34;data.bin\u0026#34;, std::ios::in | std::ios::out | std::ios::binary); if (file.is_open()) { // 移动到第二条记录 file.seekg(sizeof(Record), std::ios::beg); Record record; file.read(reinterpret_cast\u0026lt;char*\u0026gt;(\u0026amp;record), sizeof(Record)); // 移动到文件末尾 file.seekp(0, std::ios::end); file.close(); } } 字符串流 1. 字符串输入流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;sstream\u0026gt; // 解析字符串 void parseString() { std::string data = \u0026#34;123 45.67 Hello\u0026#34;; std::istringstream iss(data); int i; double d; std::string s; iss \u0026gt;\u0026gt; i \u0026gt;\u0026gt; d \u0026gt;\u0026gt; s; std::cout \u0026lt;\u0026lt; \u0026#34;Integer: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;Double: \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;String: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // 按行解析CSV void parseCSV() { std::string csvLine = \u0026#34;John,25,New York\u0026#34;; std::istringstream iss(csvLine); std::string token; while (std::getline(iss, token, \u0026#39;,\u0026#39;)) { std::cout \u0026lt;\u0026lt; token \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 2. 字符串输出流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;sstream\u0026gt; // 构建字符串 void buildString() { std::ostringstream oss; oss \u0026lt;\u0026lt; \u0026#34;Integer: \u0026#34; \u0026lt;\u0026lt; 42 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;Double: \u0026#34; \u0026lt;\u0026lt; 3.14 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;String: \u0026#34; \u0026lt;\u0026lt; \u0026#34;Hello\u0026#34;; std::string result = oss.str(); std::cout \u0026lt;\u0026lt; result; } // 格式化输出到字符串 void formatToString() { std::ostringstream oss; oss \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2); oss \u0026lt;\u0026lt; \u0026#34;Price: $\u0026#34; \u0026lt;\u0026lt; 99.99; std::string formatted = oss.str(); } 高级I/O操作 1. 自定义流操纵算子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 自定义流操纵算子 std::ostream\u0026amp; currency(std::ostream\u0026amp; os) { os \u0026lt;\u0026lt; \u0026#34;$\u0026#34;; return os; } // 带参数的流操纵算子 class setprecision_currency { int precision; public: setprecision_currency(int p) : precision(p) {} friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const setprecision_currency\u0026amp; pc) { os \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(pc.precision); return os; } }; // 使用示例 void useCustomManipulators() { double price = 99.99; std::cout \u0026lt;\u0026lt; currency \u0026lt;\u0026lt; setprecision_currency(2) \u0026lt;\u0026lt; price \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 2. 文件系统操作（C++17） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;filesystem\u0026gt; namespace fs = std::filesystem; void fileSystemOperations() { // 创建目录 fs::create_directory(\u0026#34;example_dir\u0026#34;); // 复制文件 fs::copy_file(\u0026#34;source.txt\u0026#34;, \u0026#34;dest.txt\u0026#34;, fs::copy_options::overwrite_existing); // 遍历目录 for (const auto\u0026amp; entry : fs::directory_iterator(\u0026#34;example_dir\u0026#34;)) { std::cout \u0026lt;\u0026lt; entry.path() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // 文件信息 fs::path p = \u0026#34;example.txt\u0026#34;; if (fs::exists(p)) { std::cout \u0026lt;\u0026lt; \u0026#34;File size: \u0026#34; \u0026lt;\u0026lt; fs::file_size(p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;Last write time: \u0026#34; \u0026lt;\u0026lt; fs::last_write_time(p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // 路径操作 fs::path filePath = \u0026#34;dir/subdir/file.txt\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Extension: \u0026#34; \u0026lt;\u0026lt; filePath.extension() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;Filename: \u0026#34; \u0026lt;\u0026lt; filePath.filename() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;Parent path: \u0026#34; \u0026lt;\u0026lt; filePath.parent_path() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 3. 错误处理和异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void errorHandling() { try { std::ifstream file(\u0026#34;nonexistent.txt\u0026#34;); if (!file) { throw std::runtime_error(\u0026#34;Could not open file\u0026#34;); } // 文件操作... } catch (const std::exception\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // 使用异常掩码 std::ifstream file; file.exceptions(std::ifstream::failbit | std::ifstream::badbit); try { file.open(\u0026#34;example.txt\u0026#34;); // 文件操作... file.close(); } catch (const std::ios_base::failure\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;I/O error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } ","date":"2024-03-07T14:11:27+08:00","permalink":"https://imhy.top/p/10.-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8Cio%E6%B5%81/","title":"10. 文件操作和IO流"},{"content":"基础数据类型 1. 整数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 有符号整数 int8_t i8 = -128; // -128 到 127 int16_t i16 = 32767; // -32768 到 32767 int32_t i32 = 2147483647; // -2147483648 到 2147483647 int64_t i64 = 9223372036854775807LL; // 64位整数 // 无符号整数 uint8_t u8 = 255; // 0 到 255 uint16_t u16 = 65535; // 0 到 65535 uint32_t u32 = 4294967295U; // 0 到 4294967295 uint64_t u64 = 18446744073709551615ULL; // 64位无符号整数 // 常用整数类型 short s = 32767; // 通常16位 int i = 2147483647; // 通常32位 long l = 2147483647L; // 32位或64位 long long ll = 9223372036854775807LL; // 至少64位 2. 浮点类型 1 2 3 4 5 6 7 float f = 3.14159f; // 单精度浮点数，约7位有效数字 double d = 3.14159265359; // 双精度浮点数，约15-17位有效数字 long double ld = 3.14159265358979323846L; // 扩展精度 // 科学计数法 double sci = 1.23e-4; // 0.000123 double sci2 = 1.23e4; // 12300.0 3. 字符和字符串 1 2 3 4 5 6 7 8 9 10 11 12 // 字符 char c = \u0026#39;A\u0026#39;; // 单个字符 wchar_t wc = L\u0026#39;你\u0026#39;; // 宽字符 char16_t c16 = u\u0026#39;你\u0026#39;; // UTF-16字符 char32_t c32 = U\u0026#39;你\u0026#39;; // UTF-32字符 // 字符串 const char* str = \u0026#34;Hello\u0026#34;; // C风格字符串 std::string cpp_str = \u0026#34;Hello\u0026#34;; // C++风格字符串 std::wstring wstr = L\u0026#34;你好\u0026#34;; // 宽字符串 std::u16string str16 = u\u0026#34;你好\u0026#34;; // UTF-16字符串 std::u32string str32 = U\u0026#34;你好\u0026#34;; // UTF-32字符串 4. 布尔类型 1 2 bool flag = true; // true 或 false bool result = (1 \u0026lt; 2); // 比较表达式 5. 空类型 1 2 3 4 5 void function() { // 无返回值的函数 // ... } int* ptr = nullptr; // 空指针（C++11） 变量声明和初始化 1. 变量声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 基本声明 int count; // 默认初始化 int value = 42; // 复制初始化 int number(42); // 直接初始化 int data{42}; // 统一初始化（C++11） // const 常量 const int MAX_VALUE = 100; // 常量声明 constexpr int SIZE = 42; // 编译期常量（C++11） // auto 类型推导 auto x = 42; // int auto y = 3.14; // double auto str = \u0026#34;Hello\u0026#34;; // const char* 2. 类型转换 1 2 3 4 5 6 7 8 9 10 // 隐式转换 int i = 42; double d = i; // int 转 double // 显式转换 double pi = 3.14159; int rounded = static_cast\u0026lt;int\u0026gt;(pi); // double 转 int // C风格转换（不推荐） int old_style = (int)pi; 运算符 1. 算术运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 int a = 10, b = 3; int sum = a + b; // 加法: 13 int diff = a - b; // 减法: 7 int prod = a * b; // 乘法: 30 int quot = a / b; // 整除: 3 int rem = a % b; // 取余: 1 // 自增自减 int x = 5; ++x; // 前缀自增: 6 x++; // 后缀自增: 7 --x; // 前缀自减: 6 x--; // 后缀自减: 5 2. 比较运算符 1 2 3 4 5 6 bool equal = (a == b); // 相等 bool not_equal = (a != b); // 不相等 bool greater = (a \u0026gt; b); // 大于 bool less = (a \u0026lt; b); // 小于 bool ge = (a \u0026gt;= b); // 大于等于 bool le = (a \u0026lt;= b); // 小于等于 3. 逻辑运算符 1 2 3 4 5 6 7 bool p = true, q = false; bool conjunction = p \u0026amp;\u0026amp; q; // 逻辑与 bool disjunction = p || q; // 逻辑或 bool negation = !p; // 逻辑非 // 短路求值 bool result = (p \u0026amp;\u0026amp; someFunction()); // 如果p为false，不会调用someFunction 控制流语句 1. 条件语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // if-else if (x \u0026gt; 0) { std::cout \u0026lt;\u0026lt; \u0026#34;Positive\u0026#34;; } else if (x \u0026lt; 0) { std::cout \u0026lt;\u0026lt; \u0026#34;Negative\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Zero\u0026#34;; } // switch switch (grade) { case \u0026#39;A\u0026#39;: std::cout \u0026lt;\u0026lt; \u0026#34;Excellent\u0026#34;; break; case \u0026#39;B\u0026#39;: std::cout \u0026lt;\u0026lt; \u0026#34;Good\u0026#34;; break; default: std::cout \u0026lt;\u0026lt; \u0026#34;Unknown\u0026#34;; } // 条件运算符 int abs_value = (x \u0026gt;= 0) ? x : -x; 2. 循环语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // for循环 for (int i = 0; i \u0026lt; 10; ++i) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // 范围for循环（C++11） std::vector\u0026lt;int\u0026gt; numbers = {1, 2, 3, 4, 5}; for (const auto\u0026amp; num : numbers) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // while循环 int count = 0; while (count \u0026lt; 5) { std::cout \u0026lt;\u0026lt; count++ \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // do-while循环 int num; do { std::cout \u0026lt;\u0026lt; \u0026#34;Enter a number (0 to quit): \u0026#34;; std::cin \u0026gt;\u0026gt; num; } while (num != 0); 3. 跳转语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // break for (int i = 0; i \u0026lt; 10; ++i) { if (i == 5) break; // 跳出循环 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // continue for (int i = 0; i \u0026lt; 10; ++i) { if (i % 2 == 0) continue; // 跳过偶数 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // return int sum(int a, int b) { return a + b; // 返回并结束函数 } // goto（不推荐使用） int i = 0; start: if (i \u0026lt; 5) { std::cout \u0026lt;\u0026lt; i++ \u0026lt;\u0026lt; \u0026#34; \u0026#34;; goto start; } 输入输出 1. 标准输入输出 1 2 3 4 5 6 7 8 9 10 11 12 13 // 输出 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\u0026#34; \u0026lt;\u0026lt; std::endl; // 输出字符串并换行 std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; 42 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 输出多个值 // 输入 int number; std::cout \u0026lt;\u0026lt; \u0026#34;Enter a number: \u0026#34;; std::cin \u0026gt;\u0026gt; number; // 字符串输入 std::string name; std::cout \u0026lt;\u0026lt; \u0026#34;Enter your name: \u0026#34;; std::getline(std::cin, name); // 读取整行 2. 格式化输出 1 2 3 4 5 6 7 #include \u0026lt;iomanip\u0026gt; double pi = 3.14159265359; std::cout \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2) \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; // 3.14 // 设置字段宽度 std::cout \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::right \u0026lt;\u0026lt; \u0026#34;Hello\u0026#34; \u0026lt;\u0026lt; std::endl; // \u0026#34; Hello\u0026#34; ","date":"2024-03-07T14:11:27+08:00","permalink":"https://imhy.top/p/2.-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8E%A7%E5%88%B6%E6%B5%81/","title":"2. 基础数据类型和控制流"},{"content":"数组基础 1. 固定大小数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 声明和初始化 int numbers[5] = {1, 2, 3, 4, 5}; // 完整初始化 int partial[5] = {1, 2}; // 部分初始化，其余为0 int inferred[] = {1, 2, 3}; // 自动推导大小 // 多维数组 int matrix[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }; // 访问元素 int first = numbers[0]; // 下标访问 numbers[4] = 10; // 修改元素 // 数组大小 size_t size = sizeof(numbers) / sizeof(numbers[0]); 2. 动态数组 1 2 3 4 5 6 7 8 9 10 11 12 // 使用new分配 int* dynamic = new int[5]; dynamic[0] = 1; // ... 使用数组 delete[] dynamic; // 必须释放内存 // C++11 std::array #include \u0026lt;array\u0026gt; std::array\u0026lt;int, 5\u0026gt; arr = {1, 2, 3, 4, 5}; std::cout \u0026lt;\u0026lt; arr.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 5 std::cout \u0026lt;\u0026lt; arr.front() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 第一个元素 std::cout \u0026lt;\u0026lt; arr.back() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 最后一个元素 字符串处理 1. C风格字符串 1 2 3 4 5 6 7 8 9 10 11 // 字符数组 char str[] = \u0026#34;Hello\u0026#34;; // 包含结尾的\u0026#39;\\0\u0026#39; const char* ptr = \u0026#34;World\u0026#34;; // 字符串字面量 // 常用函数 #include \u0026lt;cstring\u0026gt; size_t len = strlen(str); // 字符串长度 char dest[10]; strcpy(dest, str); // 字符串复制 strcat(dest, \u0026#34; World\u0026#34;); // 字符串拼接 int cmp = strcmp(str, ptr); // 字符串比较 2. std::string 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;string\u0026gt; // 创建和初始化 std::string s1 = \u0026#34;Hello\u0026#34;; std::string s2(\u0026#34;World\u0026#34;); std::string s3(5, \u0026#39;*\u0026#39;); // ***** // 字符串操作 s1 += \u0026#34; \u0026#34; + s2; // 字符串拼接 std::cout \u0026lt;\u0026lt; s1.length() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 字符串长度 std::cout \u0026lt;\u0026lt; s1.empty() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 是否为空 // 子字符串和查找 std::string sub = s1.substr(0, 5); // 提取子串 size_t pos = s1.find(\u0026#34;World\u0026#34;); // 查找子串 s1.replace(0, 5, \u0026#34;Hi\u0026#34;); // 替换子串 // 遍历字符串 for (char c : s1) { std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } STL容器 1. 顺序容器 vector（动态数组） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;vector\u0026gt; // 创建和初始化 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3}; std::vector\u0026lt;std::string\u0026gt; names(3, \u0026#34;unknown\u0026#34;); // 添加和删除元素 vec.push_back(4); // 末尾添加 vec.pop_back(); // 末尾删除 vec.insert(vec.begin(), 0); // 插入元素 vec.erase(vec.begin()); // 删除元素 // 访问元素 std::cout \u0026lt;\u0026lt; vec[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 下标访问 std::cout \u0026lt;\u0026lt; vec.at(1) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 带边界检查的访问 std::cout \u0026lt;\u0026lt; vec.front() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 第一个元素 std::cout \u0026lt;\u0026lt; vec.back() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 最后一个元素 ","date":"2024-03-07T14:11:27+08:00","permalink":"https://imhy.top/p/3.-%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AE%B9%E5%99%A8/","title":"3. 数组、字符串和容器"},{"content":"指针基础 1. 指针概念 1 2 3 4 5 6 7 8 9 // 指针声明和初始化 int num = 42; int* ptr = \u0026amp;num; // 指向num的指针 int* null_ptr = nullptr; // 空指针（C++11） // 指针操作 std::cout \u0026lt;\u0026lt; ptr \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 打印地址 std::cout \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 解引用，打印42 *ptr = 100; // 通过指针修改值 2. 指针算术 1 2 3 4 5 6 7 8 9 10 11 12 int arr[] = {1, 2, 3, 4, 5}; int* p = arr; // 指向数组首元素 // 指针移动 p++; // 移动到下一个元素 p--; // 移动到上一个元素 p += 2; // 向前移动2个元素 p -= 2; // 向后移动2个元素 // 指针比较 bool isFirst = (p == arr); // 是否指向首元素 bool isLast = (p == \u0026amp;arr[4]); // 是否指向最后元素 3. const和指针 1 2 3 4 5 6 7 8 // const指针的不同形式 const int* p1 = \u0026amp;num; // 指向常量的指针（不能通过指针修改值） int* const p2 = \u0026amp;num; // 常量指针（不能修改指针指向） const int* const p3 = \u0026amp;num; // 指向常量的常量指针 // 错误用法示例 *p1 = 100; // 错误：不能修改const int*指向的值 p2 = \u0026amp;other_num; // 错误：不能修改const指针的指向 引用基础 1. 引用概念 1 2 3 4 5 6 7 8 // 引用声明和初始化 int num = 42; int\u0026amp; ref = num; // ref是num的引用 ref = 100; // 修改num的值 // 引用必须初始化 int\u0026amp; invalid_ref; // 错误：引用必须初始化 int\u0026amp; ref2 = ref; // 正确：引用的引用 2. 引用vs指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void modifyByPtr(int* ptr) { if (ptr) { // 需要检查空指针 *ptr = 100; } } void modifyByRef(int\u0026amp; ref) { ref = 100; // 不需要检查，引用总是有效 } // 使用示例 int num = 42; modifyByPtr(\u0026amp;num); // 传递地址 modifyByRef(num); // 直接传递变量 3. const引用 1 2 3 4 5 6 7 8 // const引用 const int\u0026amp; cref = num; // 常量引用 // cref = 100; // 错误：不能通过常量引用修改值 // 常用于函数参数 void printValue(const int\u0026amp; val) { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 动态内存管理 1. new和delete 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 单个对象 int* p1 = new int(42); // 分配并初始化 delete p1; // 释放内存 // 数组 int* arr = new int[5]{1,2,3,4,5}; // 分配并初始化数组 delete[] arr; // 释放数组内存 // 二维数组 int rows = 3, cols = 4; int** matrix = new int*[rows]; for (int i = 0; i \u0026lt; rows; ++i) { matrix[i] = new int[cols]; } // 释放二维数组 for (int i = 0; i \u0026lt; rows; ++i) { delete[] matrix[i]; } delete[] matrix; 2. 内存泄漏防范 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 常见的内存泄漏情况 void leakMemory() { int* p = new int(42); // 忘记delete return; // 内存泄漏！ } // 使用智能指针防止泄漏 #include \u0026lt;memory\u0026gt; void noLeak() { std::unique_ptr\u0026lt;int\u0026gt; p(new int(42)); // 自动释放内存 } 智能指针 1. unique_ptr 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;memory\u0026gt; // 创建和使用 std::unique_ptr\u0026lt;int\u0026gt; up(new int(42)); std::unique_ptr\u0026lt;int\u0026gt; up2 = std::make_unique\u0026lt;int\u0026gt;(42); // C++14 // 访问数据 std::cout \u0026lt;\u0026lt; *up \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 解引用 up.reset(new int(100)); // 重置指针 int* raw = up.get(); // 获取原始指针 // 所有权转移 std::unique_ptr\u0026lt;int\u0026gt; up3 = std::move(up); // up变为nullptr 2. shared_ptr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;memory\u0026gt; // 创建和使用 std::shared_ptr\u0026lt;int\u0026gt; sp1(new int(42)); std::shared_ptr\u0026lt;int\u0026gt; sp2 = std::make_shared\u0026lt;int\u0026gt;(42); // 共享所有权 std::shared_ptr\u0026lt;int\u0026gt; sp3 = sp1; // 引用计数加1 std::cout \u0026lt;\u0026lt; sp1.use_count() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 打印2 // 重置和检查 sp1.reset(); // 放弃所有权 if (sp1) { // 检查是否为空 std::cout \u0026lt;\u0026lt; *sp1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 3. weak_ptr 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;memory\u0026gt; // 创建和使用 std::shared_ptr\u0026lt;int\u0026gt; sp(new int(42)); std::weak_ptr\u0026lt;int\u0026gt; wp = sp; // 不增加引用计数 // 使用weak_ptr if (auto spt = wp.lock()) { // 获取shared_ptr std::cout \u0026lt;\u0026lt; *spt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;对象已释放\\n\u0026#34;; } 常见陷阱和最佳实践 1. 悬垂指针 1 2 3 4 5 6 7 8 9 10 // 错误示例 int* dangling() { int local = 42; return \u0026amp;local; // 错误：返回局部变量地址 } // 正确做法 std::unique_ptr\u0026lt;int\u0026gt; safe() { return std::make_unique\u0026lt;int\u0026gt;(42); } 2. 循环引用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct Node { std::shared_ptr\u0026lt;Node\u0026gt; next; // std::weak_ptr\u0026lt;Node\u0026gt; prev; // 使用weak_ptr避免循环引用 std::shared_ptr\u0026lt;Node\u0026gt; prev; // 可能导致循环引用 }; // 避免循环引用 void createNodes() { auto node1 = std::make_shared\u0026lt;Node\u0026gt;(); auto node2 = std::make_shared\u0026lt;Node\u0026gt;(); node1-\u0026gt;next = node2; node2-\u0026gt;prev = node1; // 形成循环引用，内存永远不会释放 } 3. 指针安全使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 指针检查 void safePointerUse(int* ptr) { if (!ptr) { throw std::invalid_argument(\u0026#34;空指针\u0026#34;); } // 使用指针 *ptr = 42; } // RAII原则 class Resource { int* data; public: Resource() : data(new int(42)) {} ~Resource() { delete data; } // 禁止拷贝 Resource(const Resource\u0026amp;) = delete; Resource\u0026amp; operator=(const Resource\u0026amp;) = delete; // 允许移动 Resource(Resource\u0026amp;\u0026amp; other) noexcept : data(other.data) { other.data = nullptr; } Resource\u0026amp; operator=(Resource\u0026amp;\u0026amp; other) noexcept { if (this != \u0026amp;other) { delete data; data = other.data; other.data = nullptr; } return *this; } }; ","date":"2024-03-07T14:11:27+08:00","permalink":"https://imhy.top/p/4.-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/","title":"4. 指针和引用"},{"content":"类的基本概念 1. 类的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Person { private: std::string name; int age; public: // 构造函数 Person() : name(\u0026#34;Unknown\u0026#34;), age(0) {} // 默认构造函数 Person(const std::string\u0026amp; n, int a) : name(n), age(a) {} // 带参构造函数 // 成员函数 void setName(const std::string\u0026amp; n) { name = n; } void setAge(int a) { age = a; } std::string getName() const { return name; } int getAge() const { return age; } // 析构函数 ~Person() {} }; 2. 访问控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class AccessExample { private: int privateVar; // 只能在类内部访问 protected: int protectedVar; // 可在类内部和派生类中访问 public: int publicVar; // 可在任何地方访问 void accessDemo() { privateVar = 1; // OK protectedVar = 2; // OK publicVar = 3; // OK } }; 3. 静态成员 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Counter { private: static int count; // 静态成员变量声明 int id; public: Counter() : id(++count) {} static int getCount() { // 静态成员函数 return count; } int getId() const { return id; } }; // 静态成员变量定义 int Counter::count = 0; // 使用示例 Counter c1, c2; std::cout \u0026lt;\u0026lt; Counter::getCount() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 输出2 构造和析构 1. 构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MyClass { private: int* data; public: // 默认构造函数 MyClass() : data(new int(0)) {} // 带参构造函数 MyClass(int value) : data(new int(value)) {} // 拷贝构造函数 MyClass(const MyClass\u0026amp; other) : data(new int(*other.data)) {} // 移动构造函数 MyClass(MyClass\u0026amp;\u0026amp; other) noexcept : data(other.data) { other.data = nullptr; } // 析构函数 ~MyClass() { delete data; } }; 2. 初始化列表 1 2 3 4 5 6 7 8 9 10 11 12 13 class Rectangle { private: int width; int height; const double ratio; public: // 使用初始化列表初始化成员 Rectangle(int w, int h) : width(w) , height(h) , ratio(static_cast\u0026lt;double\u0026gt;(w) / h) {} }; 3. 委托构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 class Delegate { private: int x, y, z; public: // 主构造函数 Delegate(int x, int y, int z) : x(x), y(y), z(z) {} // 委托构造函数 Delegate() : Delegate(0, 0, 0) {} Delegate(int x) : Delegate(x, 0, 0) {} Delegate(int x, int y) : Delegate(x, y, 0) {} }; 继承和多态 1. 基类和派生类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 基类 class Shape { protected: std::string name; public: Shape(const std::string\u0026amp; n) : name(n) {} virtual double area() const = 0; // 纯虚函数 virtual double perimeter() const = 0; virtual ~Shape() {} // 虚析构函数 }; // 派生类 class Circle : public Shape { private: double radius; public: Circle(double r) : Shape(\u0026#34;Circle\u0026#34;), radius(r) {} double area() const override { return M_PI * radius * radius; } double perimeter() const override { return 2 * M_PI * radius; } }; class Rectangle : public Shape { private: double width, height; public: Rectangle(double w, double h) : Shape(\u0026#34;Rectangle\u0026#34;), width(w), height(h) {} double area() const override { return width * height; } double perimeter() const override { return 2 * (width + height); } }; 2. 多态性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void printArea(const Shape\u0026amp; shape) { std::cout \u0026lt;\u0026lt; \u0026#34;Area: \u0026#34; \u0026lt;\u0026lt; shape.area() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // 使用示例 Circle circle(5); Rectangle rect(4, 6); printArea(circle); // 多态调用Circle::area() printArea(rect); // 多态调用Rectangle::area() // 使用基类指针 std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt; shapes; shapes.push_back(std::make_unique\u0026lt;Circle\u0026gt;(5)); shapes.push_back(std::make_unique\u0026lt;Rectangle\u0026gt;(4, 6)); for (const auto\u0026amp; shape : shapes) { printArea(*shape); // 多态调用 } 3. 虚函数和抽象类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class AbstractBase { public: virtual void method1() = 0; // 纯虚函数 virtual void method2() = 0; virtual ~AbstractBase() = default; }; class Concrete : public AbstractBase { public: void method1() override { std::cout \u0026lt;\u0026lt; \u0026#34;Implemented method1\\n\u0026#34;; } void method2() override { std::cout \u0026lt;\u0026lt; \u0026#34;Implemented method2\\n\u0026#34;; } }; 运算符重载 1. 成员函数重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Complex { private: double real, imag; public: Complex(double r = 0, double i = 0) : real(r), imag(i) {} // 重载加法运算符 Complex operator+(const Complex\u0026amp; other) const { return Complex(real + other.real, imag + other.imag); } // 重载赋值运算符 Complex\u0026amp; operator=(const Complex\u0026amp; other) { if (this != \u0026amp;other) { real = other.real; imag = other.imag; } return *this; } // 重载复合赋值运算符 Complex\u0026amp; operator+=(const Complex\u0026amp; other) { real += other.real; imag += other.imag; return *this; } // 重载下标运算符 double\u0026amp; operator[](int index) { if (index == 0) return real; if (index == 1) return imag; throw std::out_of_range(\u0026#34;Index out of range\u0026#34;); } }; 2. 友元函数重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class String { private: char* str; public: String(const char* s = \u0026#34;\u0026#34;) { str = new char[strlen(s) + 1]; strcpy(str, s); } ~String() { delete[] str; } // 声明友元函数 friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const String\u0026amp; s); friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, String\u0026amp; s); }; // 重载输出运算符 std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const String\u0026amp; s) { os \u0026lt;\u0026lt; s.str; return os; } // 重载输入运算符 std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, String\u0026amp; s) { char temp[1000]; is \u0026gt;\u0026gt; temp; delete[] s.str; s.str = new char[strlen(temp) + 1]; strcpy(s.str, temp); return is; } 3. 类型转换运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Fraction { private: int num, den; public: Fraction(int n = 0, int d = 1) : num(n), den(d) {} // 转换为double的运算符 operator double() const { return static_cast\u0026lt;double\u0026gt;(num) / den; } // 转换为bool的运算符 explicit operator bool() const { return num != 0; } }; // 使用示例 Fraction f(3, 2); double d = f; // 调用operator double() if (f) { // 调用operator bool() std::cout \u0026lt;\u0026lt; \u0026#34;Fraction is non-zero\\n\u0026#34;; } 特殊成员函数 1. Rule of Five 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Resource { private: int* data; public: // 构造函数 Resource(int value = 0) : data(new int(value)) {} // 析构函数 ~Resource() { delete data; } // 拷贝构造函数 Resource(const Resource\u0026amp; other) : data(new int(*other.data)) {} // 拷贝赋值运算符 Resource\u0026amp; operator=(const Resource\u0026amp; other) { if (this != \u0026amp;other) { int* newData = new int(*other.data); delete data; data = newData; } return *this; } // 移动构造函数 Resource(Resource\u0026amp;\u0026amp; other) noexcept : data(other.data) { other.data = nullptr; } // 移动赋值运算符 Resource\u0026amp; operator=(Resource\u0026amp;\u0026amp; other) noexcept { if (this != \u0026amp;other) { delete data; data = other.data; other.data = nullptr; } return *this; } }; 2. 禁用特殊成员函数 1 2 3 4 5 6 7 8 9 10 11 12 class Uncopyable { public: Uncopyable() = default; // 禁用拷贝 Uncopyable(const Uncopyable\u0026amp;) = delete; Uncopyable\u0026amp; operator=(const Uncopyable\u0026amp;) = delete; // 允许移动 Uncopyable(Uncopyable\u0026amp;\u0026amp;) = default; Uncopyable\u0026amp; operator=(Uncopyable\u0026amp;\u0026amp;) = default; }; ","date":"2024-03-07T14:11:27+08:00","permalink":"https://imhy.top/p/5.-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","title":"5. 类和对象"},{"content":"类型推导 1. auto关键字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 基本用法 auto i = 42; // int auto d = 3.14; // double auto str = \u0026#34;hello\u0026#34;; // const char* auto vec = std::vector\u0026lt;int\u0026gt;{1, 2, 3}; // std::vector\u0026lt;int\u0026gt; // 与const和引用配合 const auto\u0026amp; val = someFunction(); // 常量引用 auto\u0026amp;\u0026amp; ref = someValue; // 通用引用（完美转发） // 在循环中使用 std::vector\u0026lt;std::pair\u0026lt;std::string, int\u0026gt;\u0026gt; pairs; for (const auto\u0026amp; [name, value] : pairs) { // 结构化绑定（C++17） std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 2. decltype关键字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 推导表达式类型 int i = 42; decltype(i) j = i; // int std::vector\u0026lt;int\u0026gt; vec; decltype(vec[0]) val = 42; // int\u0026amp; // 用于后置返回类型 template\u0026lt;typename T, typename U\u0026gt; auto add(T t, U u) -\u0026gt; decltype(t + u) { return t + u; } // decltype(auto)（C++14） decltype(auto) f() { int x = 0; return (x); // 返回int\u0026amp;，因为(x)是左值表达式 } 3. 类型推导规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 模板类型推导 template\u0026lt;typename T\u0026gt; void f(T param); int x = 42; const int cx = x; const int\u0026amp; rx = x; f(x); // T 推导为 int f(cx); // T 推导为 int f(rx); // T 推导为 int // auto类型推导 auto x1 = 27; // int const auto x2 = x1; // const int const auto\u0026amp; x3 = x1; // const int\u0026amp; auto\u0026amp;\u0026amp; x4 = x1; // int\u0026amp; auto\u0026amp;\u0026amp; x5 = 27; // int\u0026amp;\u0026amp; Lambda表达式 1. 基本语法 1 2 3 4 5 6 7 8 9 10 11 12 // 最简单的lambda auto lambda1 = [] { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Lambda\\n\u0026#34;; }; lambda1(); // 调用 // 带参数的lambda auto lambda2 = [](int x, int y) { return x + y; }; std::cout \u0026lt;\u0026lt; lambda2(3, 4) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 输出7 // 指定返回类型 auto lambda3 = [](int x, double y) -\u0026gt; double { return x + y; }; 2. 捕获列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int multiplier = 10; std::string prefix = \u0026#34;Result: \u0026#34;; // 值捕获 auto lambda1 = [multiplier](int x) { return x * multiplier; }; // 引用捕获 auto lambda2 = [\u0026amp;prefix](int x) { prefix += std::to_string(x); }; // 混合捕获 auto lambda3 = [multiplier, \u0026amp;prefix](int x) { prefix += std::to_string(x * multiplier); }; // 捕获this指针 class MyClass { int value; public: auto getValueLambda() { return [this] { return value; }; } }; // 广义捕获（C++14） auto lambda4 = [ptr = std::make_unique\u0026lt;int\u0026gt;(42)] { return *ptr; }; 3. 泛型Lambda（C++14） 1 2 3 4 5 6 7 8 9 10 11 12 13 // 自动推导参数类型 auto lambda = [](auto x, auto y) { return x + y; }; std::cout \u0026lt;\u0026lt; lambda(1, 2) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // int std::cout \u0026lt;\u0026lt; lambda(1.5, 2.3) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // double std::cout \u0026lt;\u0026lt; lambda(\u0026#34;Hello\u0026#34;s, \u0026#34; World\u0026#34;s) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // string // 带模板参数的lambda（C++20） auto lambda2 = []\u0026lt;typename T\u0026gt;(std::vector\u0026lt;T\u0026gt; const\u0026amp; vec) { return vec.size(); }; 移动语义 1. 右值引用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 右值引用基础 int\u0026amp;\u0026amp; rref = 42; // 右值引用 std::string\u0026amp;\u0026amp; sref = std::string(\u0026#34;hello\u0026#34;); // 临时对象的右值引用 // 移动构造函数 class MyClass { std::string str; public: MyClass(MyClass\u0026amp;\u0026amp; other) noexcept : str(std::move(other.str)) {} // 移动构造 }; // 移动赋值运算符 MyClass\u0026amp; operator=(MyClass\u0026amp;\u0026amp; other) noexcept { if (this != \u0026amp;other) { str = std::move(other.str); } return *this; } 2. 完美转发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 通用引用和完美转发 template\u0026lt;typename T\u0026gt; void wrapper(T\u0026amp;\u0026amp; arg) { // 完美转发参数 foo(std::forward\u0026lt;T\u0026gt;(arg)); } // 多参数完美转发 template\u0026lt;typename... Args\u0026gt; void wrapper(Args\u0026amp;\u0026amp;... args) { foo(std::forward\u0026lt;Args\u0026gt;(args)...); } // 工厂函数示例 template\u0026lt;typename T, typename... Args\u0026gt; std::unique_ptr\u0026lt;T\u0026gt; make_unique(Args\u0026amp;\u0026amp;... args) { return std::unique_ptr\u0026lt;T\u0026gt;( new T(std::forward\u0026lt;Args\u0026gt;(args)...) ); } 3. 移动语义最佳实践 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Buffer { std::vector\u0026lt;char\u0026gt; data; public: // 移动优化 void append(std::string\u0026amp;\u0026amp; str) { data.insert(data.end(), str.begin(), str.end()); } // 返回值优化 std::vector\u0026lt;char\u0026gt; extract() { return std::move(data); // 显式移动 } }; // 条件移动 template\u0026lt;typename T\u0026gt; void conditionalMove(T\u0026amp; obj) { if (/* 某些条件 */) { other.takeOwnership(std::move(obj)); } } 其他现代特性 1. 范围for循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 std::vector\u0026lt;int\u0026gt; numbers = {1, 2, 3, 4, 5}; // 基本用法 for (const auto\u0026amp; num : numbers) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // 自定义类型的范围for class Range { int* begin_; int* end_; public: int* begin() { return begin_; } int* end() { return end_; } }; // 初始化器for循环（C++20） for (std::vector\u0026lt;int\u0026gt; vec{1, 2, 3}; const auto\u0026amp; num : vec) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 2. 智能指针增强 1 2 3 4 5 6 7 8 9 10 11 12 13 // make_unique（C++14） auto ptr1 = std::make_unique\u0026lt;int\u0026gt;(42); auto ptr2 = std::make_unique\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(10, 0); // 数组支持 auto arr = std::make_unique\u0026lt;int[]\u0026gt;(10); // shared_ptr with custom deleter auto deleter = [](int* p) { std::cout \u0026lt;\u0026lt; \u0026#34;Deleting \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; delete p; }; std::shared_ptr\u0026lt;int\u0026gt; ptr(new int(42), deleter); 3. constexpr增强 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // constexpr函数 constexpr int fibonacci(int n) { if (n \u0026lt;= 1) return n; return fibonacci(n-1) + fibonacci(n-2); } // constexpr变量 constexpr int fib10 = fibonacci(10); // constexpr构造函数（C++14） class Point { int x_, y_; public: constexpr Point(int x, int y) : x_(x), y_(y) {} constexpr int getX() const { return x_; } constexpr int getY() const { return y_; } }; // constexpr if（C++17） template\u0026lt;typename T\u0026gt; auto getValue(T t) { if constexpr (std::is_pointer_v\u0026lt;T\u0026gt;) { return *t; } else { return t; } } 4. 结构化绑定（C++17） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 数组绑定 int arr[] = {1, 2, 3}; auto [x, y, z] = arr; // 元组绑定 std::tuple\u0026lt;int, std::string, double\u0026gt; tuple{1, \u0026#34;hello\u0026#34;, 3.14}; auto [id, name, value] = tuple; // 结构体绑定 struct Point { int x; int y; }; Point p{1, 2}; auto [px, py] = p; // 在循环中使用 std::map\u0026lt;std::string, int\u0026gt; scores; for (const auto\u0026amp; [name, score] : scores) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; score \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } ","date":"2024-03-07T14:11:27+08:00","permalink":"https://imhy.top/p/6.-%E7%8E%B0%E4%BB%A3c-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7/","title":"6. 现代C++核心特性"},{"content":"函数模板 1. 基本语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 简单的函数模板 template\u0026lt;typename T\u0026gt; T max(T a, T b) { return (a \u0026gt; b) ? a : b; } // 使用示例 int i = max(10, 20); // T 为 int double d = max(3.14, 2.72); // T 为 double std::string s = max(\u0026#34;hello\u0026#34;s, \u0026#34;world\u0026#34;s); // T 为 string // 多个模板参数 template\u0026lt;typename T, typename U\u0026gt; auto add(T a, U b) -\u0026gt; decltype(a + b) { return a + b; } // 使用示例 auto result = add(10, 3.14); // 返回类型为double 2. 模板参数推导 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 自动推导 template\u0026lt;typename T\u0026gt; void print(T value) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } print(42); // T 推导为 int print(\u0026#34;hello\u0026#34;); // T 推导为 const char* // 显式指定类型 print\u0026lt;double\u0026gt;(42); // T 为 double // 推导指引（C++17） template\u0026lt;typename T\u0026gt; class Container { T value; public: Container(T val) : value(val) {} }; Container container{42}; // 自动推导为Container\u0026lt;int\u0026gt; 3. 非类型模板参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 使用非类型参数 template\u0026lt;typename T, size_t N\u0026gt; class Array { T data[N]; public: constexpr size_t size() const { return N; } T\u0026amp; operator[](size_t i) { return data[i]; } }; // 使用示例 Array\u0026lt;int, 5\u0026gt; arr; // 固定大小的数组 static_assert(arr.size() == 5); // 非类型参数作为常量 template\u0026lt;int Base\u0026gt; int power(int exp) { int result = 1; for(int i = 0; i \u0026lt; exp; ++i) { result *= Base; } return result; } int value = power\u0026lt;2\u0026gt;(3); // 计算2的3次方 类模板 1. 基本定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 简单的类模板 template\u0026lt;typename T\u0026gt; class Box { private: T content; public: Box(T value) : content(value) {} T get() const { return content; } void set(T value) { content = value; } }; // 使用示例 Box\u0026lt;int\u0026gt; intBox(42); Box\u0026lt;std::string\u0026gt; strBox(\u0026#34;Hello\u0026#34;); // 多个模板参数 template\u0026lt;typename K, typename V\u0026gt; class Pair { K key; V value; public: Pair(const K\u0026amp; k, const V\u0026amp; v) : key(k), value(v) {} K getKey() const { return key; } V getValue() const { return value; } }; 2. 成员函数模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template\u0026lt;typename T\u0026gt; class Container { public: // 成员函数模板 template\u0026lt;typename U\u0026gt; void copyFrom(const Container\u0026lt;U\u0026gt;\u0026amp; other) { // 从其他类型容器复制 } // 构造函数模板 template\u0026lt;typename U\u0026gt; Container(const Container\u0026lt;U\u0026gt;\u0026amp; other) { copyFrom(other); } }; // 使用示例 Container\u0026lt;double\u0026gt; doubleContainer; Container\u0026lt;int\u0026gt; intContainer(doubleContainer); // 隐式转换 3. 模板特化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 主模板 template\u0026lt;typename T\u0026gt; class SmartPtr { T* ptr; public: SmartPtr(T* p) : ptr(p) {} ~SmartPtr() { delete ptr; } T\u0026amp; operator*() { return *ptr; } }; // 完全特化 template\u0026lt;\u0026gt; class SmartPtr\u0026lt;void\u0026gt; { void* ptr; public: SmartPtr(void* p) : ptr(p) {} ~SmartPtr() { free(ptr); } }; // 偏特化 template\u0026lt;typename T\u0026gt; class SmartPtr\u0026lt;T[]\u0026gt; { T* ptr; public: SmartPtr(T* p) : ptr(p) {} ~SmartPtr() { delete[] ptr; } T\u0026amp; operator[](size_t i) { return ptr[i]; } }; 变参模板 1. 基础用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 变参函数模板 template\u0026lt;typename... Args\u0026gt; void printAll(Args... args) { (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; args) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 折叠表达式（C++17） } // 使用示例 printAll(1, \u0026#34;hello\u0026#34;, 3.14); // 打印：1hello3.14 // 递归方式展开参数包 template\u0026lt;typename T\u0026gt; void print(T value) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } template\u0026lt;typename T, typename... Args\u0026gt; void print(T first, Args... rest) { std::cout \u0026lt;\u0026lt; first \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; print(rest...); } 2. 折叠表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 使用折叠表达式（C++17） template\u0026lt;typename... Args\u0026gt; auto sum(Args... args) { return (... + args); // 一元左折叠 } template\u0026lt;typename... Args\u0026gt; bool allTrue(Args... args) { return (... \u0026amp;\u0026amp; args); // 一元左折叠 } // 带初始值的折叠 template\u0026lt;typename... Args\u0026gt; auto sumWithInit(Args... args) { return (0 + ... + args); // 二元左折叠 } 3. 变参类模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 变参类模板 template\u0026lt;typename... Types\u0026gt; class Tuple; // 特化为空 template\u0026lt;\u0026gt; class Tuple\u0026lt;\u0026gt; {}; // 递归特化 template\u0026lt;typename Head, typename... Tail\u0026gt; class Tuple\u0026lt;Head, Tail...\u0026gt; : private Tuple\u0026lt;Tail...\u0026gt; { Head head; public: Tuple(Head h, Tail... tail) : Tuple\u0026lt;Tail...\u0026gt;(tail...), head(h) {} Head getHead() const { return head; } }; 模板元编程 1. 编译期计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 编译期阶乘计算 template\u0026lt;unsigned N\u0026gt; struct Factorial { static constexpr unsigned value = N * Factorial\u0026lt;N-1\u0026gt;::value; }; template\u0026lt;\u0026gt; struct Factorial\u0026lt;0\u0026gt; { static constexpr unsigned value = 1; }; // 使用示例 constexpr auto fact5 = Factorial\u0026lt;5\u0026gt;::value; // 120 // 编译期if template\u0026lt;bool Condition, typename T, typename U\u0026gt; struct Conditional { using type = T; }; template\u0026lt;typename T, typename U\u0026gt; struct Conditional\u0026lt;false, T, U\u0026gt; { using type = U; }; 2. 类型特征 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 自定义类型特征 template\u0026lt;typename T\u0026gt; struct IsPointer { static constexpr bool value = false; }; template\u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;T*\u0026gt; { static constexpr bool value = true; }; // 使用示例 static_assert(IsPointer\u0026lt;int*\u0026gt;::value); static_assert(!IsPointer\u0026lt;int\u0026gt;::value); // 类型变换 template\u0026lt;typename T\u0026gt; struct RemovePointer { using type = T; }; template\u0026lt;typename T\u0026gt; struct RemovePointer\u0026lt;T*\u0026gt; { using type = T; }; 3. SFINAE和概念 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // SFINAE示例 template\u0026lt;typename T\u0026gt; typename std::enable_if\u0026lt;std::is_integral\u0026lt;T\u0026gt;::value, bool\u0026gt;::type isEven(T t) { return t % 2 == 0; } // 使用概念（C++20） template\u0026lt;typename T\u0026gt; concept Numeric = std::is_arithmetic_v\u0026lt;T\u0026gt;; template\u0026lt;Numeric T\u0026gt; T add(T a, T b) { return a + b; } // 复合概念 template\u0026lt;typename T\u0026gt; concept Sortable = requires(T\u0026amp; a, T\u0026amp; b) { { a \u0026lt; b } -\u0026gt; std::convertible_to\u0026lt;bool\u0026gt;; std::swap(a, b); }; 4. 元函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 类型计算 template\u0026lt;typename T\u0026gt; struct AddConst { using type = const T; }; // 值计算 template\u0026lt;typename T\u0026gt; struct TypeSize { static constexpr size_t value = sizeof(T); }; // 条件元编程 template\u0026lt;typename T\u0026gt; struct IsLargeType { static constexpr bool value = sizeof(T) \u0026gt; 8; }; // 使用示例 using ConstInt = typename AddConst\u0026lt;int\u0026gt;::type; constexpr size_t intSize = TypeSize\u0026lt;int\u0026gt;::value; constexpr bool isLarge = IsLargeType\u0026lt;std::string\u0026gt;::value; ","date":"2024-03-07T14:11:27+08:00","permalink":"https://imhy.top/p/7.-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/","title":"7. 模板和泛型编程"},{"content":"线程基础 1. 创建和管理线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;thread\u0026gt; #include \u0026lt;iostream\u0026gt; // 线程函数 void threadFunction() { std::cout \u0026lt;\u0026lt; \u0026#34;Thread running\\n\u0026#34;; } // 带参数的线程函数 void threadWithParams(int x, std::string str) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread with params: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { // 创建线程 std::thread t1(threadFunction); // 创建带参数的线程 std::thread t2(threadWithParams, 42, \u0026#34;Hello\u0026#34;); // 使用lambda表达式 std::thread t3([]() { std::cout \u0026lt;\u0026lt; \u0026#34;Lambda thread\\n\u0026#34;; }); // 等待线程完成 t1.join(); t2.join(); t3.join(); // 分离线程 std::thread t4(threadFunction); t4.detach(); // 检查线程是否可以join if (t4.joinable()) { t4.join(); } return 0; } 2. 线程标识和硬件并发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;thread\u0026gt; void printThreadInfo() { // 获取当前线程ID std::thread::id thisId = std::this_thread::get_id(); // 获取硬件支持的并发线程数 unsigned int numThreads = std::thread::hardware_concurrency(); std::cout \u0026lt;\u0026lt; \u0026#34;Thread ID: \u0026#34; \u0026lt;\u0026lt; thisId \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Hardware Concurrency: \u0026#34; \u0026lt;\u0026lt; numThreads \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // 线程本地存储 thread_local int counter = 0; void threadLocalDemo() { ++counter; // 每个线程都有自己的counter副本 std::cout \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34; counter: \u0026#34; \u0026lt;\u0026lt; counter \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 3. 线程生命周期管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class ThreadGuard { std::thread\u0026amp; t; public: explicit ThreadGuard(std::thread\u0026amp; t_) : t(t_) {} ~ThreadGuard() { if (t.joinable()) { t.join(); } } // 禁止拷贝和赋值 ThreadGuard(const ThreadGuard\u0026amp;) = delete; ThreadGuard\u0026amp; operator=(const ThreadGuard\u0026amp;) = delete; }; void threadLifecycle() { std::thread t([]() { std::cout \u0026lt;\u0026lt; \u0026#34;Working...\\n\u0026#34;; }); ThreadGuard guard(t); // 确保线程在作用域结束时被join // 其他代码... } // guard析构，自动join线程 同步机制 1. 互斥量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;mutex\u0026gt; class Counter { private: mutable std::mutex mutex; int value = 0; public: // 基本互斥 void increment() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); ++value; } // 使用unique_lock（更灵活） void decrement() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mutex); --value; // lock.unlock(); // 可以提前解锁 // lock.lock(); // 可以重新加锁 } // const成员函数中的互斥 int get() const { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); return value; } }; // 死锁避免 class BankAccount { std::mutex mutex; double balance; public: void transfer(BankAccount\u0026amp; other, double amount) { // 使用std::lock同时锁定两个互斥量 std::lock(mutex, other.mutex); std::lock_guard\u0026lt;std::mutex\u0026gt; lock1(mutex, std::adopt_lock); std::lock_guard\u0026lt;std::mutex\u0026gt; lock2(other.mutex, std::adopt_lock); balance -= amount; other.balance += amount; } }; 2. 条件变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;condition_variable\u0026gt; class ThreadSafeQueue { private: std::mutex mutex; std::condition_variable cv; std::queue\u0026lt;int\u0026gt; queue; public: void push(int value) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); queue.push(value); cv.notify_one(); // 通知一个等待的线程 } int pop() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mutex); cv.wait(lock, [this]() { return !queue.empty(); }); int value = queue.front(); queue.pop(); return value; } // 带超时的等待 bool try_pop(int\u0026amp; value, const std::chrono::milliseconds\u0026amp; timeout) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mutex); if (!cv.wait_for(lock, timeout, [this]() { return !queue.empty(); })) { return false; // 超时 } value = queue.front(); queue.pop(); return true; } }; 3. 读写锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;shared_mutex\u0026gt; class ThreadSafeMap { private: mutable std::shared_mutex mutex; std::map\u0026lt;std::string, int\u0026gt; data; public: // 写操作（独占锁） void write(const std::string\u0026amp; key, int value) { std::unique_lock\u0026lt;std::shared_mutex\u0026gt; lock(mutex); data[key] = value; } // 读操作（共享锁） bool read(const std::string\u0026amp; key, int\u0026amp; value) const { std::shared_lock\u0026lt;std::shared_mutex\u0026gt; lock(mutex); auto it = data.find(key); if (it == data.end()) { return false; } value = it-\u0026gt;second; return true; } }; 异步编程 1. Future和Promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;future\u0026gt; // 使用async std::future\u0026lt;int\u0026gt; calculateAsync() { return std::async(std::launch::async, []() { std::this_thread::sleep_for(std::chrono::seconds(1)); return 42; }); } // 使用promise void produceValue(std::promise\u0026lt;int\u0026gt; promise) { try { // 计算值 int result = someComputation(); promise.set_value(result); } catch (...) { promise.set_exception(std::current_exception()); } } // 使用packaged_task int compute(int x) { return x * x; } void futureDemo() { // async示例 auto future1 = calculateAsync(); int result1 = future1.get(); // 等待结果 // promise示例 std::promise\u0026lt;int\u0026gt; promise; std::future\u0026lt;int\u0026gt; future2 = promise.get_future(); std::thread t(produceValue, std::move(promise)); int result2 = future2.get(); t.join(); // packaged_task示例 std::packaged_task\u0026lt;int(int)\u0026gt; task(compute); std::future\u0026lt;int\u0026gt; future3 = task.get_future(); task(4); int result3 = future3.get(); } 2. 异步任务组合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 串行组合 template\u0026lt;typename F, typename G\u0026gt; auto then(std::future\u0026lt;F\u0026gt;\u0026amp;\u0026amp; f, G\u0026amp;\u0026amp; g) { return std::async(std::launch::async, [f = std::move(f), g = std::forward\u0026lt;G\u0026gt;(g)]() mutable { return g(f.get()); }); } // 并行组合 template\u0026lt;typename F, typename G\u0026gt; auto both(std::future\u0026lt;F\u0026gt;\u0026amp;\u0026amp; f, std::future\u0026lt;G\u0026gt;\u0026amp;\u0026amp; g) { return std::async(std::launch::async, [f = std::move(f), g = std::move(g)]() mutable { auto result_f = f.get(); auto result_g = g.get(); return std::make_pair(result_f, result_g); }); } 3. 协程（C++20） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;coroutine\u0026gt; #include \u0026lt;iostream\u0026gt; // 简单的协程示例 struct Generator { struct promise_type { int current_value; Generator get_return_object() { return Generator{std::coroutine_handle\u0026lt;promise_type\u0026gt;::from_promise(*this)}; } auto initial_suspend() { return std::suspend_never{}; } auto final_suspend() noexcept { return std::suspend_always{}; } void return_void() {} void unhandled_exception() { std::terminate(); } auto yield_value(int value) { current_value = value; return std::suspend_always{}; } }; std::coroutine_handle\u0026lt;promise_type\u0026gt; handle; Generator(std::coroutine_handle\u0026lt;promise_type\u0026gt; h) : handle(h) {} ~Generator() { if (handle) handle.destroy(); } int current_value() { return handle.promise().current_value; } bool move_next() { return handle.resume(); } }; // 生成斐波那契数列的协程 Generator fibonacci() { int a = 0, b = 1; while (true) { co_yield a; auto tmp = a; a = b; b = tmp + b; } } 并发数据结构 1. 无锁队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 template\u0026lt;typename T\u0026gt; class LockFreeQueue { private: struct Node { std::shared_ptr\u0026lt;T\u0026gt; data; std::atomic\u0026lt;Node*\u0026gt; next; Node() : next(nullptr) {} }; std::atomic\u0026lt;Node*\u0026gt; head; std::atomic\u0026lt;Node*\u0026gt; tail; public: LockFreeQueue() { Node* dummy = new Node; head.store(dummy); tail.store(dummy); } void push(T value) { Node* new_node = new Node; new_node-\u0026gt;data = std::make_shared\u0026lt;T\u0026gt;(std::move(value)); while (true) { Node* old_tail = tail.load(); Node* next = old_tail-\u0026gt;next.load(); if (old_tail == tail.load()) { if (next == nullptr) { if (old_tail-\u0026gt;next.compare_exchange_weak(next, new_node)) { tail.compare_exchange_weak(old_tail, new_node); return; } } else { tail.compare_exchange_weak(old_tail, next); } } } } std::shared_ptr\u0026lt;T\u0026gt; pop() { while (true) { Node* old_head = head.load(); Node* old_tail = tail.load(); Node* next = old_head-\u0026gt;next.load(); if (old_head == head.load()) { if (old_head == old_tail) { if (next == nullptr) { return nullptr; } tail.compare_exchange_weak(old_tail, next); } else { auto result = next-\u0026gt;data; if (head.compare_exchange_weak(old_head, next)) { delete old_head; return result; } } } } } }; 2. 线程安全单例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Singleton { public: static Singleton\u0026amp; getInstance() { static Singleton instance; // C++11保证线程安全的初始化 return instance; } // 删除拷贝和移动操作 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; private: Singleton() = default; }; // 双检查锁定模式（不推荐，仅作示例） class SingletonDCL { private: static std::atomic\u0026lt;SingletonDCL*\u0026gt; instance; static std::mutex mutex; SingletonDCL() = default; public: static SingletonDCL* getInstance() { SingletonDCL* tmp = instance.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire); if (tmp == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); tmp = instance.load(std::memory_order_relaxed); if (tmp == nullptr) { tmp = new SingletonDCL; std::atomic_thread_fence(std::memory_order_release); instance.store(tmp, std::memory_order_relaxed); } } return tmp; } }; ","date":"2024-03-07T14:11:27+08:00","permalink":"https://imhy.top/p/8.-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/","title":"8. 并发和多线程编程"},{"content":"顺序容器 1. vector 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;vector\u0026gt; // 基本操作 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; vec.push_back(6); // 添加元素 vec.pop_back(); // 移除最后一个元素 vec.insert(vec.begin() + 2, 10); // 在指定位置插入 vec.erase(vec.begin()); // 删除指定位置的元素 // 容量管理 vec.reserve(100); // 预分配空间 vec.shrink_to_fit(); // 释放多余空间 std::cout \u0026lt;\u0026lt; vec.capacity(); // 当前容量 std::cout \u0026lt;\u0026lt; vec.size(); // 当前大小 // 访问元素 int first = vec.front(); // 第一个元素 int last = vec.back(); // 最后一个元素 int third = vec[2]; // 下标访问 int safe_access = vec.at(2); // 带边界检查的访问 // 遍历 for (const auto\u0026amp; elem : vec) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 2. deque 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;deque\u0026gt; std::deque\u0026lt;int\u0026gt; dq = {1, 2, 3}; // 双端操作 dq.push_front(0); // 前端添加 dq.push_back(4); // 后端添加 dq.pop_front(); // 前端删除 dq.pop_back(); // 后端删除 // 随机访问 dq[2] = 10; // 修改元素 dq.insert(dq.begin() + 2, 5); // 插入元素 dq.erase(dq.end() - 1); // 删除元素 // 大小操作 dq.resize(10); // 调整大小 dq.shrink_to_fit(); // 优化内存使用 3. list和forward_list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;list\u0026gt; #include \u0026lt;forward_list\u0026gt; // 双向链表 std::list\u0026lt;int\u0026gt; lst = {1, 2, 3, 4, 5}; lst.push_front(0); // 前端添加 lst.push_back(6); // 后端添加 lst.insert(++lst.begin(), 7); // 插入元素 lst.sort(); // 排序 lst.reverse(); // 反转 lst.unique(); // 移除连续重复元素 lst.merge(other_list); // 合并两个有序链表 // 单向链表 std::forward_list\u0026lt;int\u0026gt; flst = {1, 2, 3}; flst.push_front(0); // 只能在前端添加 flst.insert_after(flst.begin(), 4); // 在指定位置之后插入 flst.erase_after(flst.begin()); // 删除指定位置之后的元素 关联容器 1. set和multiset 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;set\u0026gt; // 集合 std::set\u0026lt;int\u0026gt; s = {3, 1, 4, 1, 5}; // 自动排序和去重 s.insert(2); // 插入元素 s.erase(1); // 删除元素 auto it = s.find(4); // 查找元素 bool exists = s.count(3) \u0026gt; 0; // 检查存在性 // 多重集合 std::multiset\u0026lt;int\u0026gt; ms = {1, 1, 2, 2, 3}; ms.insert(1); // 允许重复元素 auto range = ms.equal_range(1); // 获取所有等于1的元素范围 2. map和multimap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;map\u0026gt; // 映射 std::map\u0026lt;std::string, int\u0026gt; scores = { {\u0026#34;Alice\u0026#34;, 95}, {\u0026#34;Bob\u0026#34;, 89} }; // 插入和访问 scores[\u0026#34;Charlie\u0026#34;] = 92; // 插入或更新 scores.insert({\u0026#34;David\u0026#34;, 88}); // 插入 auto it = scores.find(\u0026#34;Alice\u0026#34;); // 查找 scores.erase(\u0026#34;Bob\u0026#34;); // 删除 // 遍历 for (const auto\u0026amp; [name, score] : scores) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; score \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // 多重映射 std::multimap\u0026lt;std::string, int\u0026gt; grades; grades.insert({\u0026#34;Alice\u0026#34;, 95}); grades.insert({\u0026#34;Alice\u0026#34;, 92}); // 允许重复键 3. unordered容器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;unordered_set\u0026gt; #include \u0026lt;unordered_map\u0026gt; // 无序集合 std::unordered_set\u0026lt;int\u0026gt; us = {1, 2, 3, 4, 5}; us.insert(6); // O(1)平均时间复杂度 us.erase(1); auto it = us.find(3); // 无序映射 std::unordered_map\u0026lt;std::string, int\u0026gt; um = { {\u0026#34;one\u0026#34;, 1}, {\u0026#34;two\u0026#34;, 2} }; um[\u0026#34;three\u0026#34;] = 3; um.erase(\u0026#34;one\u0026#34;); // 自定义类型作为键 struct Point { int x, y; bool operator==(const Point\u0026amp; other) const { return x == other.x \u0026amp;\u0026amp; y == other.y; } }; struct PointHash { size_t operator()(const Point\u0026amp; p) const { return std::hash\u0026lt;int\u0026gt;()(p.x) ^ std::hash\u0026lt;int\u0026gt;()(p.y); } }; std::unordered_set\u0026lt;Point, PointHash\u0026gt; points; 容器适配器 1. stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stack\u0026gt; std::stack\u0026lt;int\u0026gt; st; st.push(1); // 压栈 st.push(2); st.push(3); while (!st.empty()) { std::cout \u0026lt;\u0026lt; st.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 查看栈顶 st.pop(); // 出栈 } // 自定义底层容器 std::stack\u0026lt;int, std::vector\u0026lt;int\u0026gt;\u0026gt; stack_vec; std::stack\u0026lt;int, std::deque\u0026lt;int\u0026gt;\u0026gt; stack_deq; 2. queue和priority_queue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;queue\u0026gt; // 队列 std::queue\u0026lt;int\u0026gt; q; q.push(1); // 入队 q.push(2); q.push(3); while (!q.empty()) { std::cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 查看队首 q.pop(); // 出队 } // 优先队列 std::priority_queue\u0026lt;int\u0026gt; pq; // 默认最大堆 std::priority_queue\u0026lt;int, std::vector\u0026lt;int\u0026gt;, std::greater\u0026lt;int\u0026gt;\u0026gt; min_pq; // 最小堆 pq.push(3); pq.push(1); pq.push(4); while (!pq.empty()) { std::cout \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 获取最大/最小元素 pq.pop(); } STL算法 1. 非修改序列算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 2, 4, 5, 2}; // 计数和查找 int count_2 = std::count(vec.begin(), vec.end(), 2); auto it = std::find(vec.begin(), vec.end(), 4); bool has_6 = std::any_of(vec.begin(), vec.end(), [](int x) { return x == 6; }); // 比较 bool is_sorted = std::is_sorted(vec.begin(), vec.end()); auto [min, max] = std::minmax_element(vec.begin(), vec.end()); // 搜索 auto it2 = std::search(vec.begin(), vec.end(), pattern.begin(), pattern.end()); 2. 修改序列算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 复制和移动 std::vector\u0026lt;int\u0026gt; dest(vec.size()); std::copy(vec.begin(), vec.end(), dest.begin()); std::move(vec.begin(), vec.end(), dest.begin()); // 转换 std::transform(vec.begin(), vec.end(), vec.begin(), [](int x) { return x * 2; }); // 删除和替换 auto new_end = std::remove(vec.begin(), vec.end(), 2); vec.erase(new_end, vec.end()); std::replace(vec.begin(), vec.end(), 3, 30); // 重排 std::reverse(vec.begin(), vec.end()); std::rotate(vec.begin(), vec.begin() + 2, vec.end()); std::shuffle(vec.begin(), vec.end(), std::random_device{}); 3. 排序和相关算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 排序 std::sort(vec.begin(), vec.end()); std::sort(vec.begin(), vec.end(), std::greater\u0026lt;int\u0026gt;()); // 部分排序 std::partial_sort(vec.begin(), vec.begin() + 3, vec.end()); std::nth_element(vec.begin(), vec.begin() + 3, vec.end()); // 合并和集合操作 std::vector\u0026lt;int\u0026gt; merged; std::merge(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), std::back_inserter(merged)); std::vector\u0026lt;int\u0026gt; intersection; std::set_intersection(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), std::back_inserter(intersection)); 4. 数值算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;numeric\u0026gt; std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 累加 int sum = std::accumulate(vec.begin(), vec.end(), 0); int product = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies\u0026lt;int\u0026gt;()); // 内积 std::vector\u0026lt;int\u0026gt; vec2 = {2, 3, 4, 5, 6}; int dot_product = std::inner_product(vec.begin(), vec.end(), vec2.begin(), 0); // 部分和 std::vector\u0026lt;int\u0026gt; partial_sums; std::partial_sum(vec.begin(), vec.end(), std::back_inserter(partial_sums)); // 相邻差 std::vector\u0026lt;int\u0026gt; differences; std::adjacent_difference(vec.begin(), vec.end(), std::back_inserter(differences)); ","date":"2024-03-07T14:11:27+08:00","permalink":"https://imhy.top/p/9.-stl%E5%AE%B9%E5%99%A8%E5%92%8C%E7%AE%97%E6%B3%95/","title":"9. STL容器和算法"},{"content":"C++的发展历程 1. 历史沿革 诞生阶段（1979-1983）\nBjarne Stroustrup 在贝尔实验室开发\u0026quot;C with Classes\u0026quot; 增加类、继承等面向对象特性 保持与C语言的兼容性 标准化阶段（1983-1998）\n1983年命名为C++ 1985年发布第一个商业版本 1998年发布第一个ISO标准（C++98） 现代化阶段（2011至今）\nC++11：现代C++的开端 C++14：小幅改进 C++17：增加文件系统等特性 C++20：协程、模块等重大更新 C++23：最新标准 2. 主要特性演进 C++98/03\n标准模板库（STL） 异常处理 命名空间 RTTI（运行时类型识别） C++11\n自动类型推导（auto） 基于范围的for循环 Lambda表达式 智能指针 右值引用和移动语义 C++14/17/20\n泛型lambda 文件系统库 并行算法 协程 模块系统 开发环境搭建 1. IDE选择 CLion（推荐）\n跨平台支持 内置CMake支持 强大的代码分析和重构功能 集成调试器 安装：scoop install clion Visual Studio\nWindows平台最佳选择 完整的开发工具链 优秀的调试功能 VSCode + 插件\n轻量级选择 需要额外配置 2. 工具链配置 编译器选择\nLLVM-MinGW 基于LLVM/Clang的Windows工具链\n更好的错误诊断和编译速度\n完整的C++标准支持\n安装步骤：\n1 2 # 安装llvm-mingw scoop install llvm-mingw 构建系统（Ninja）\n高性能构建系统，替代传统的Make 特点： 更快的构建速度 更简单的构建规则 更好的增量构建支持 并行构建能力强 CLion已内置Ninja，无需额外安装 包管理器（vcpkg）\n用于管理C++第三方库\n支持Windows/Linux/MacOS\n安装步骤：\n1 2 3 4 5 # 安装vcpkg scoop install vcpkg # 初始化vcpkg（首次使用时运行） vcpkg integrate install 3. CLion项目配置 配置LLVM-MinGW工具链\n打开 File \u0026gt; Settings \u0026gt; Build, Execution, Deployment \u0026gt; Toolchains 点击 + 添加新工具链，选择 MinGW 设置 MinGW Home 为 %USERPROFILE%\\scoop\\apps\\llvm-mingw\\current 确保自动检测到以下工具： C Compiler: cc.exe C++ Compiler: c++.exe Debugger: lldb.exe 如果需要手动设置编译器路径： C Compiler: %USERPROFILE%\\scoop\\apps\\llvm-mingw\\current\\bin\\cc.exe C++ Compiler: %USERPROFILE%\\scoop\\apps\\llvm-mingw\\current\\bin\\c++.exe 将此工具链移动到列表顶部设为默认 新建项目\n选择 File \u0026gt; New Project 选择 C++ Executable 在 Toolchain 下拉菜单中选择配置好的LLVM-MinGW CMake会自动配置 配置运行设置\n点击顶部工具栏的 \u0026ldquo;Add Configuration\u0026rdquo; 或 \u0026ldquo;Edit Configurations\u0026rdquo; 点击左上角 \u0026ldquo;+\u0026rdquo; 按钮，选择 \u0026ldquo;CMake Application\u0026rdquo; 配置选项： Name：为配置命名（如项目名称） Target：选择要运行的目标（通常是项目名） Executable：自动选择生成的可执行文件 可以创建多个配置： Debug配置：用于调试 Release配置：用于性能测试 配置工作目录（Working Directory）如果需要 设置程序参数（Program arguments）如果需要 点击 \u0026ldquo;OK\u0026rdquo; 保存配置 配置CMake\nCLion默认配置说明：\n新建项目时自动创建基本CMake配置 默认包含Debug和Release两种模式 基本的编译和运行功能已经可用 适合简单项目和学习使用 手动配置（推荐用于正式项目）：\n进入 File \u0026gt; Settings \u0026gt; Build, Execution, Deployment \u0026gt; CMake 创建两个CMake Profile：Debug和Release，都绑定到LLVM-MinGW工具链 在 Generator 下拉菜单中选择 Ninja Debug配置在 CMake options 中添加以下选项： 1 -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON Release配置在 CMake options 中添加以下选项：\n1 -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=ON 选项说明：\n-G Ninja：使用Ninja构建系统，比Make更快 -DCMAKE_BUILD_TYPE=Debug/Release：设置构建类型 Debug：包含调试信息，不优化 Release：开启优化，移除调试信息 -DCMAKE_EXPORT_COMPILE_COMMANDS=ON：生成编译命令数据库，用于代码分析 在CMakeLists.txt中添加链接器选项：\n1 2 # 使用lld链接器 add_link_options(-fuse-ld=lld) 点击 Apply 并重新加载CMake项目\n可以在CLion底部工具栏切换Debug和Release模式\n基本CMake配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 # CMakeLists.txt cmake_minimum_required(VERSION 3.30) project(CppLearning) # 包管理配置 # 注意：vcpkg配置必须在其他配置之前设置 set(CMAKE_TOOLCHAIN_FILE \u0026#34;$ENV{USERPROFILE}/scoop/apps/vcpkg/current/scripts/buildsystems/vcpkg.cmake\u0026#34;) # C++标准设置 set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_STANDARD_REQUIRED ON) # 强制使用指定的C++标准，如果编译器不支持则报错 set(CMAKE_CXX_EXTENSIONS OFF) # 禁用编译器特定扩展，确保跨平台兼容性 # 编译选项 add_compile_options( -Wall # 启用所有警告 -Wextra # 启用额外警告 -Wpedantic # 严格遵守标准 -Werror # 将警告视为错误 -fdiagnostics-color=always # 彩色诊断信息 ) # 性能优化选项 # Release模式优化设置 # 注意：如果用于逆向工程学习，建议降低或禁用优化，使生成的代码更易于分析 # -O0: 禁用优化 # -O1: 基本优化 # -O2: 中等优化 # -O3: 最高优化级别 set(CMAKE_CXX_FLAGS_RELEASE \u0026#34;-O2\u0026#34;) # 使用中等优化级别，在性能和可读性间平衡 # 如果用于逆向工程学习，可以使用以下设置： # set(CMAKE_CXX_FLAGS_RELEASE \u0026#34;-O0 -g\u0026#34;) # 禁用优化并保留调试信息 # Debug模式设置 set(CMAKE_CXX_FLAGS_DEBUG \u0026#34;-O0 -g\u0026#34;) # 禁用优化，包含调试信息 # 创建可执行文件 add_executable(main main.cpp) # 添加依赖（如果需要） find_package(fmt CONFIG REQUIRED) target_link_libraries(main PRIVATE fmt::fmt) 4. 代码风格配置 CLion内置格式化\nFile \u0026gt; Settings \u0026gt; Editor \u0026gt; Code Style \u0026gt; C/C++ 可导入Google或LLVM风格 Clang-Format配置\n1 2 3 4 # .clang-format BasedOnStyle: Google IndentWidth: 4 ColumnLimit: 100 5. 调试配置 CLion调试设置\n设置断点：点击行号左侧或使用 Ctrl + F8 启动调试：点击虫子图标或使用 Shift + F9 调试控制： F8：单步执行（Step Over） F7：步入函数（Step Into） Shift + F8：步出函数（Step Out） F9：继续执行（Resume） 变量监视\n自动窗口：显示当前上下文的变量 监视窗口：添加要跟踪的变量表达式 求值：使用 Alt + F8 计算表达式 LLDB调试器使用\n命令行调试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 编译带调试信息的程序 clang++ -g -O0 main.cpp -o main # 启动调试器 lldb main # 常用命令 breakpoint set --file main.cpp --line 10 # 设置断点 run # 运行程序 frame variable # 查看变量 print variable_name # 打印变量值 continue # 继续执行 quit # 退出调试器 6. 性能优化 编译优化\n发布模式：\n1 2 3 4 5 6 7 8 # 启用链接时优化 set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE) # 使用快速数学 add_compile_options(-ffast-math) # 启用SIMD指令 add_compile_options(-march=native) 调试模式\n添加调试信息：\n1 2 set(CMAKE_CXX_FLAGS_DEBUG \u0026#34;${CMAKE_CXX_FLAGS_DEBUG} -fno-omit-frame-pointer\u0026#34;) set(CMAKE_CXX_FLAGS_DEBUG \u0026#34;${CMAKE_CXX_FLAGS_DEBUG} -fsanitize=address\u0026#34;) 7. 常见问题解决 编译器配置问题\n找不到编译器：\n检查LLVM-MinGW安装路径 确认环境变量是否正确设置 尝试重启CLion 编译错误：\n检查CMake选项中的编译器设置 确保使用正确的C++标准 查看Build输出获取详细错误信息 CMake配置问题\nCMake刷新失败：\n删除build目录重新配置 检查CMakeLists.txt语法 确认所有依赖路径正确 CMake缓存错误（Error: could not load cache）：\n在CLion中： 点击 File \u0026gt; Invalidate Caches / Restart 选择 Invalidate and Restart 手动清理： 删除项目的 cmake-build-* 目录 重新打开项目，让CLion重新生成CMake配置 缓存清理后的重新配置： 等待CLion重新启动 点击右下角的 \u0026ldquo;Load CMake Project\u0026rdquo; 重新检查工具链配置（Toolchains） 重新设置CMake配置（Debug和Release） 等待项目重新加载和索引 如果问题仍然存在： 检查CMakeLists.txt中的项目名称是否正确 确认CMake版本要求是否与安装版本匹配 验证所有路径中不包含特殊字符 找不到包：\n确认vcpkg正确安装和集成 检查CMAKE_TOOLCHAIN_FILE路径 运行 vcpkg install package:x64-windows 安装缺失的包 vcpkg集成问题\n环境变量设置：\n1 2 3 4 5 6 # 设置VCPKG_ROOT环境变量 [Environment]::SetEnvironmentVariable( \u0026#34;VCPKG_ROOT\u0026#34;, \u0026#34;$env:USERPROFILE\\scoop\\apps\\vcpkg\\current\u0026#34;, \u0026#34;User\u0026#34; ) 包安装失败：\n检查网络连接 确认包名称和平台正确 尝试清理vcpkg缓存：vcpkg remove --outdated 第一个程序 1. Hello World 1 2 3 4 5 6 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, Modern C++!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 2. 构建和运行 使用CLion\n点击运行按钮 或使用快捷键 Shift + F10 使用命令行\n1 2 3 4 5 # 编译 clang++ -std=c++17 main.cpp -o main # 运行 ./main 推荐学习资源 官方文档\nC++ Reference CLion Documentation 在线教程\nModern C++ Tutorial C++ Core Guidelines 书籍推荐\n《C++ Primer》（第5版） 《Effective Modern C++》 《C++ Templates》（第2版） ","date":"2024-03-07T10:30:00+08:00","permalink":"https://imhy.top/p/1.-c-%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"1. C++发展历程和环境搭建"},{"content":"简介 GoldenDict 是一款功能强大的开源词典软件，支持多种词典格式，可以集成在线翻译服务，是学习和工作中不可或缺的翻译工具。\n主要特点：\n支持多种词典格式（StarDict、Babylon、Lingvo 等） 可集成在线翻译服务（Google、DeepL 等） 支持全文搜索 跨平台支持（Windows、Linux、macOS） 可定制的界面和快捷键 安装 使用 Scoop 安装 1 2 # 安装 GoldenDict scoop install goldendict 便携模式说明 Scoop 安装的 GoldenDict 默认启用便携模式（Portable Mode），这意味着：\n配置目录\n在程序目录下会自动创建 portable 文件夹 所有配置文件都存储在这个文件夹中 路径通常为：%SCOOP%/apps/goldendict/current/portable 词典目录限制\n便携模式下只能识别 content 文件夹中的词典 无法通过界面添加其他目录的词典 路径为：%SCOOP%/apps/goldendict/current/content 解决方案\n将词典文件复制到 content 文件夹中\n或者创建符号链接指向其他词典目录：\n1 2 # 以管理员身份运行 mklink /D \u0026#34;%SCOOP%\\apps\\goldendict\\current\\content\\词典名称\u0026#34; \u0026#34;实际词典目录路径\u0026#34; 手动安装 访问 GoldenDict 官网 或 GitHub 发布页 下载最新版本安装包 运行安装程序 词典推荐 词典下载 推荐网站：词典网站\n将词典文件放到 %SCOOP%/apps/goldendict/current/content 路径\n1. 英语词典 离线词典\n朗文当代英语词典（Longman）：英英释义详尽，例句地道 牛津高阶英汉双解词典（Oxford）：权威性强，释义准确 柯林斯高阶英汉双解词典（Collins）：例句丰富，搭配详细 剑桥高阶英汉双解词典（Cambridge）：英美发音齐全 韦氏高阶英汉双解词典（Merriam-Webster）：美式英语为主 Vocabulary.com Dictionary：词源解释详细，助记功能强 IT 专业词典\n计算机英语词典：收录专业术语 信息技术词典：包含最新 IT 领域词汇 编程语言词典：各种编程语言的专业术语 GitHub Glossary：开源社区常用术语 2. 词典格式说明 GoldenDict 支持以下主流词典格式：\nBabylon (BGL)\n文件扩展名：.bgl 特点：压缩率高，加载速度快 StarDict\n文件扩展名：.ifo, .dict, .idx 特点：开源格式，兼容性好 Lingvo (DSL)\n文件扩展名：.dsl, .dsl.dz 特点：支持复杂格式，显示效果好 MDict\n文件扩展名：.mdx, .mdd 特点：广泛使用，资源丰富 3. 词典下载地址 开源词典\nECDICT：英汉词典数据库 FreeDictionaryProject：自由词典项目 专业词典\nIT-Dictionary：IT 专业词典 MDX/MDD 词典下载：胡正维护的词典下载站 在线翻译配置 1. Google 翻译 安装翻译工具\n1 2 3 4 5 # 安装 Python（如果未安装） scoop install python # 安装 Google 翻译工具 pip3 install google-translate-for-goldendict 配置 GoldenDict\n编辑 \u0026gt; 词典 \u0026gt; 词典来源 \u0026gt; 程式 点击 添加 设置以下参数： 类型：Html 名称：Google Translate 命令行：python -m googletranslate zh-CN %GDWORD% 图示：可选，下载 google_translate.png 使用技巧 快速切换词典\n使用 Tab 键在结果中切换 使用数字键快速选择词典组 自定义样式\n使用自定义 CSS 美化界面 调整字体和颜色 优化显示布局 批量查询\n使用文本文件导入 导出查询历史 生成生词本 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/goldendict-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"GoldenDict 使用指南"},{"content":"Hugo 安装和简单使用请查看上篇文档\n主题特色 Stack 主题具有以下特色功能：\n现代化设计\n响应式布局，完美支持移动端 暗色/亮色主题切换 优雅的卡片式设计 丰富功能\n文章目录自动生成 阅读时间估算 文章字数统计 代码高亮 表情支持 图片画廊 社交集成\n社交媒体链接 文章分享功能 GitHub 编辑链接 性能优化\n延迟加载图片 代码块复制 平滑滚动 多语言支持\n内置中文支持 可扩展其他语言 安装配置 添加 Stack 主题 在个人站点目录，执行如下命令以 git 子模块的模式来添加 Stack：\n1 2 3 4 5 6 7 8 # 添加主题 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 更新主题 git submodule update --remote # 查看主题版本号 git show 拉取完毕后，打开博客文件夹内的 theme/hugo-theme-stack/exampleSite，将文件夹内的 hugo.yaml 复制到站点根目录下，同时删除原有的 hugo.toml。\n为了打造更符合自己心意的站点，需要将主题的资源复制到个人站点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # Windows 系统使用以下命令 xcopy themes\\hugo-theme-stack\\archetypes archetypes\\ /E /I xcopy themes\\hugo-theme-stack\\assets assets\\ /E /I xcopy themes\\hugo-theme-stack\\data data\\ /E /I xcopy themes\\hugo-theme-stack\\i18n i18n\\ /E /I xcopy themes\\hugo-theme-stack\\layouts layouts\\ /E /I # Linux/macOS 系统使用以下命令 cp -r themes/hugo-theme-stack/archetypes/* archetypes/ cp -r themes/hugo-theme-stack/assets/* assets/ cp -r themes/hugo-theme-stack/data/* data/ cp -r themes/hugo-theme-stack/i18n/* i18n/ cp -r themes/hugo-theme-stack/layouts/* layouts/ 配置说明 hugo.yaml 主要配置项说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 # 基础配置 baseurl: \u0026#34;https://example.com\u0026#34; # 博客的 URL languageCode: \u0026#34;zh-cn\u0026#34; # 语言代码 theme: \u0026#34;hugo-theme-stack\u0026#34; # 主题名称 paginate: 10 # 每页显示的文章数量 title: \u0026#34;我的博客\u0026#34; # 网站名称 copyright: \u0026#34;© 2024\u0026#34; # 网站底部的版权信息 # 语言设置 DefaultContentLanguage: \u0026#34;zh-cn\u0026#34; # 默认显示的语言 hasCJKLanguage: true # 中文字数统计 # 多语言设置 languages: zh-cn: languageName: \u0026#34;简体中文\u0026#34; weight: 1 title: \u0026#34;我的博客\u0026#34; [languageContentDir]: \u0026#34;content/zh-cn\u0026#34; [languageMenuName]: \u0026#34;简体中文\u0026#34; # 服务配置 services: googleAnalytics: \u0026#34;UA-XXXXXXXX-X\u0026#34; # Google 分析代码 disqus: \u0026#34;your-disqus-shortname\u0026#34; # Disqus 评论系统 utterances: \u0026#34;your-repo\u0026#34; # GitHub 评论系统 # 参数配置 params: favicon: \u0026#34;/img/favicon.ico\u0026#34; # 站点图标 footer: since: 2024 # 创建博客的年份 dateFormat: published: \u0026#34;2006-01-02\u0026#34; # 发布时间格式 lastUpdated: \u0026#34;2006-01-02 15:04 MST\u0026#34; # 最后更新时间格式 sidebar: emoji: \u0026#34;🍀\u0026#34; # 头像右下角的 emoji subtitle: \u0026#34;热爱生活\u0026#34; # 头像下方的副标题 avatar: src: \u0026#34;/img/avatar.png\u0026#34; # 头像图片位置 menu: - identifier: \u0026#34;home\u0026#34; name: \u0026#34;首页\u0026#34; url: \u0026#34;/\u0026#34; params: newTab: false - identifier: \u0026#34;about\u0026#34; name: \u0026#34;关于\u0026#34; url: \u0026#34;/about\u0026#34; params: newTab: false # 文章配置 article: math: false # 数学公式支持 toc: true # 目录显示 readingTime: true # 阅读时间 license: enabled: false # 版权信息 default: Licensed under CC BY-NC-SA 4.0 edit: enabled: true # GitHub 编辑 wordCount: true # 字数统计 # 菜单配置 menu: social: - identifier: \u0026#34;github\u0026#34; name: \u0026#34;GitHub\u0026#34; url: \u0026#34;https://github.com/yourusername\u0026#34; params: newTab: true - identifier: \u0026#34;twitter\u0026#34; name: \u0026#34;Twitter\u0026#34; url: \u0026#34;https://twitter.com/yourusername\u0026#34; params: newTab: true 功能使用 使用表情 Stack 主题已开启表情支持，可以在表情仓库查找需要的表情。\n使用示例：\n1 :smile: :heart: :rocket: 使用本地图片 Hugo 会根据内容文件的路径以及 permalinks 配置来生成 URL 和文件夹结构。\n目录结构示例：\n1 2 3 4 5 6 content/ ├── post │ └── blog │ └── images │ └── test.png │ └── first.md 编译后的结构：\n1 2 3 4 5 6 7 8 public/ ├── p │ └── first │ └── index.html └── post └── blog └── images └── test.png 在 first.md 中引用图片：\n1 ![](/post/博客搭建/images/test.png) 个性化设置 自定义小图标 访问 Tabler Icons 搜索想要的图标 设置图标参数： Size: 24px Stroke: 2px 点击图标复制 SVG 代码 在网站根目录的 assets/icons/ 文件夹创建 .svg 文件 在配置中使用图标 文章底部添加 GitHub 编辑链接 复制主题文件： 1 cp themes/hugo-theme-stack/assets/layouts/partials/article/components/footer.html layouts/partials/article/components/ 修改 footer.html： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;footer class=\u0026#34;article-footer\u0026#34;\u0026gt; {{ partial \u0026#34;article/components/tags\u0026#34; . }} {{ if and (.Site.Params.article.license.enabled) (not (eq .Params.license false)) }} \u0026lt;section class=\u0026#34;article-copyright\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;copyright\u0026#34; }} \u0026lt;span\u0026gt;{{ default .Site.Params.article.license.default .Params.license | markdownify }}\u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; {{ end }} \u0026lt;!-- GitHub 编辑链接 --\u0026gt; {{ if and (.Site.Params.article.edit.enabled) (not (eq .Params.edit false)) }} \u0026lt;section class=\u0026#34;article-edit\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;brand-github\u0026#34; }} \u0026lt;span\u0026gt; \u0026lt;a href=\u0026#34;https://github.com/yourusername/yourusername.github.io/edit/main/content/{{ replace .File.Path \u0026#34;\\\\\u0026#34; \u0026#34;/\u0026#34; }}\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34;\u0026gt; 在 GitHub 上编辑此页 \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; {{ end }} {{- if ne .Lastmod .Date -}} \u0026lt;section class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;span\u0026gt; {{ T \u0026#34;article.lastUpdatedOn\u0026#34; }} {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; {{- end -}} \u0026lt;/footer\u0026gt; 在 hugo.yaml 中启用编辑功能： 1 2 3 4 5 6 7 8 9 article: math: false toc: true readingTime: true license: enabled: false default: Licensed under CC BY-NC-SA 4.0 edit: enabled: true # 启用编辑功能 自动更新文章最后修改时间 在 hugo.yaml 中添加以下配置：\n1 2 3 4 5 6 7 8 9 10 frontmatter: # 按优先级排序： # :git - 文件提交修改时间 # lastmod - 文章里 lastmod 字段 # :fileModTime - 文件修改时间 # :default - 默认时间 lastmod: [\u0026#34;:git\u0026#34;, \u0026#34;lastmod\u0026#34;, \u0026#34;:fileModTime\u0026#34;, \u0026#34;:default\u0026#34;] enableGitInfo: true gitRepo: \u0026#34;https://github.com/yourusername/yourusername.github.io\u0026#34; 文章字数统计 修改 layouts/partials/article/components/details.html： 1 2 3 4 5 6 7 8 {{ if .Site.Params.article.wordCount }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;pencil\u0026#34; }} \u0026lt;time class=\u0026#34;article-words\u0026#34;\u0026gt; {{ .WordCount }} 字 \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 在 hugo.yaml 中启用字数统计： 1 2 article: wordCount: true 站点总字数统计 修改 layouts/partials/footer/footer.html： 1 2 3 4 5 6 7 8 9 10 {{$scratch := newScratch}} {{ range (where .Site.Pages \u0026#34;Kind\u0026#34; \u0026#34;page\u0026#34; )}} {{$scratch.Add \u0026#34;total\u0026#34; .WordCount}} {{ end }} \u0026lt;section class=\u0026#34;wordcount\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ div ($scratch.Get \u0026#34;total\u0026#34;) 1000.0 | lang.FormatNumber 2 }}k 字 \u0026lt;br\u0026gt;{{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;post\u0026#34;) }}篇文章 \u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; 修改 assets/scss/partials/footer.scss： 1 2 3 4 .wordcount { color: var(--accent-color); margin-bottom: 5px; } 界面优化 缩小归档页的分类卡片尺寸 修改 assets/scss/partials/layout/list.scss：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 .subsection-list { overflow-x: auto; .article-list--tile { display: flex; padding-bottom: 0px; article { width: 150px; height: 90px; margin-right: 5px; flex-shrink: 0; .article-title { margin: 0; font-size: 1.8rem; } .article-details { padding: 20px; } } } } 在首页文件列表显示内容简介 修改 assets/layouts/partials/article-list/default.html： 1 2 3 4 5 6 7 {{ with .Params.description }} \u0026lt;div class=\u0026#34;article-subtitle-wrapper\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;article-subtitle\u0026#34;\u0026gt; {{ . }} \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 修改 assets/scss/custom.scss： 1 2 3 4 5 6 7 8 9 .article-subtitle-wrapper { padding-left: var(--card-padding); padding-right: var(--card-padding); padding-bottom: var(--card-padding); } .article-time { padding-top: 5px; } 删除 layouts/partials/article/components/details.html 中的 article-subtitle 在归档列表显示内容简介 修改 assets/layouts/partials/article-list/compact.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;article-title\u0026#34;\u0026gt; {{- .Title -}} \u0026lt;/h2\u0026gt; {{ with .Params.description }} \u0026lt;div class=\u0026#34;article-subtitle\u0026#34;\u0026gt; {{ . }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; \u0026lt;time datetime=\u0026#39;{{ .Date.Format \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; }}\u0026#39;\u0026gt; {{- .Date.Format (or .Site.Params.dateFormat.published \u0026#34;Jan 02, 2006\u0026#34;) -}} \u0026lt;/time\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; 代码块样式优化 修改 assets/scss/partials/layout/article.scss：\n1 2 3 4 5 6 7 8 9 10 11 .highlight { margin-left: 0; margin-right: 0; width: calc(100%); border-radius: var(--card-border-radius); } .copyCodeButton { top: 5px; right: 5px; } ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/hugo-stack-%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BE%8E%E5%8C%96%E9%85%8D%E7%BD%AE/","title":"Hugo Stack 主题使用和美化配置"},{"content":"Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\n为什么选择 Hugo？ Hugo 作为静态网站生成器，具有以下优势：\n极快的构建速度：Hugo 是目前最快的静态网站生成器之一 丰富的主题生态：有大量精美的主题可供选择 强大的内容管理：支持 Markdown、HTML、JSON 等多种格式 灵活的模板系统：使用 Go 模板语法，易于定制 活跃的社区：持续更新维护，问题解决快速 完善的文档：官方文档详尽，示例丰富 多平台支持：支持 Windows、macOS、Linux 等主流操作系统 安装 hugo 有两个版本，标准版和扩展版，推荐使用扩展版。\nWindows 安装 使用 scoop 安装\n1 scoop install hugo-extended 注意：*目前scoop版本过低，编译最新stack主题的时候会报错，所以推荐使用下面方法安装。\n下载二进制安装，github地址\na. 下载二进制版本 b. 解压文件 c. 配置环境变量\n打开系统环境变量设置 在 Path 中添加 Hugo 解压目录 验证安装：打开新的命令行窗口，运行 hugo version macOS 安装 使用 Homebrew 安装\n1 brew install hugo 使用二进制安装\n下载 macOS 版本的二进制文件 解压并移动到 /usr/local/bin/ 验证安装：hugo version Linux 安装 使用包管理器安装\nUbuntu/Debian:\n1 sudo apt install hugo CentOS/RHEL:\n1 sudo dnf install hugo 使用二进制安装\n下载 Linux 版本的二进制文件 解压并移动到 /usr/local/bin/ 验证安装：hugo version 验证安装 安装完成后，运行以下命令验证安装：\n1 hugo version 扩展版可以在输出中看到 +extended 标识。\n基本命令 Hugo 提供了丰富的命令行工具，以下是一些常用命令：\n1 2 3 4 5 # 查看所有可用命令 hugo help # 查看具体命令的帮助信息 hugo server --help 新建站点 一个站点对应本地的一个文件夹，如：希望在 /site_path/site_name 路径创建一个站点\n1 hugo new site site_path/site_name 创建成功以后切换到对应路径\n1 cd site_path/site_name 可以看到如下文件结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 site_name/ ├── archetypes/ # 新内容的模板目录 │ └── default.md # 默认文章模板 ├── assets/ # 全局资源目录 │ ├── css/ # CSS 文件 │ ├── js/ # JavaScript 文件 │ └── images/ # 图片资源 ├── content/ # 网站内容目录 │ └── post/ # 文章目录 ├── data/ # 数据文件目录 ├── i18n/ # 多语言翻译目录 ├── layouts/ # 自定义布局模板 ├── static/ # 静态资源目录 ├── themes/ # 主题目录 └── hugo.toml # 站点配置文件 各目录说明：\narchetypes/: 新内容的模板目录，用于定义新文章的基本结构 assets/: 全局资源目录，包含 CSS、JavaScript、图片等资源文件 content/: 网站内容目录，存放所有文章和页面 data/: 数据文件目录，用于存放 JSON、TOML、YAML 或 XML 格式的数据文件 i18n/: 多语言翻译目录，存放不同语言的翻译文件 layouts/: 自定义布局模板目录，用于覆盖主题的默认布局 static/: 静态资源目录，存放不需要处理的静态文件 themes/: 主题目录，存放一个或多个主题 hugo.toml: 站点配置文件，定义网站的基本设置 新建文章 新建的文章会根据 archetypes/default.md 模板创建在 content/ 目录下\n1 hugo new path/test.md 本地调试 在发布文章之前，你可能希望在本地调试，在站点根路径执行 hugo 命令进行调试\n1 2 3 4 5 6 7 # 启动本地服务器 hugo server # --buildDrafts 包含草稿文章 hugo server --buildDrafts # or hugo server -D 在浏览器打开 http://localhost:1313 可查看生成的文章\n生成最终页面 将文章中的 draft 修改为 false\n1 2 3 4 hugo #开始代码压缩 hugo --minify 运行以后将在站点目录生成 public 目录，该目录包含生成的已发布网站。Hugo根据需要重新创建此目录及其内容。查看详细资料\n⚠️Hugo在构建站点前不会清空目录。 根据当前四个条件的评估结果，构建后你的目录可能包含来自以前构建的多余文件。通常的做法是在每次构建之前手动清空目录的内容以删除草稿、过期和未来的内容。\n所以推荐使用代参构建\n1 2 # 这个选项会在 Hugo 构建时清理生成目录中的内容，确保只有最新构建的文件保留 hugo --cleanDestinationDir 部署到 Github Pages 手动部署 首先在 GitHub 上创建一个名为 xxx.github.io 的仓库（xxx 为你的 GitHub 用户名）\n将 public 文件夹关联到刚创建的仓库\n1 2 3 4 5 6 7 cd public git init git remote add origin https://github.com/xxxx/xxxx.github.io.git git branch -M main git add . git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin main 之后可在浏览器访问 http://xxx.github.io 查看发布的文章\n注意：手动部署需要每次修改文章后手动编译并推送到 xxx.github.io 仓库，这种方式比较繁琐\n自动部署 创建两个仓库：\n私有库：存放博客源码（如 MySite） 公开库：xxx.github.io（用于部署） 创建 Personal Access Token (PAT)\nPAT 用于授权私有库访问目标库的权限，使 Actions 可以推送构建好的代码\n打开 GitHub Settings 进入 Developer settings 选择 Personal access tokens 点击 Tokens(classic) 勾选 workflow 和 write:packages 生成并保存 PAT（以 ghp_ 开头） 配置仓库 Secrets\n打开私有库的 Settings 选择 Secrets and variables \u0026gt; Actions 添加新的 Secret，名称为 SECRET_BLOG，值为刚才生成的 PAT 配置 GitHub Actions\n在私有库的 Actions 页面创建新的 workflow 搜索并选择 Hugo 模板 修改配置文件中的以下参数： hugo-version：设置为你的 Hugo 版本（通过 hugo version 查看） personal_token：设置为 ${{ secrets.SECRET_BLOG }} external_repository：设置为 xxx/xxx.github.io 完整的配置文件示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 name: GitHub Pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-22.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v4 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#39;0.132.2\u0026#39; extended: true - name: Build run: hugo --minify --cleanDestinationDir - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: personal_token: ${{ secrets.XXX }} publish_branch: main publish_dir: ./public external_repository: xxx/xxx.github.io cname: imhy.top 配置完成后，每次推送代码到 main 分支时，GitHub Actions 会自动构建并部署到你的个人网站。\n基础使用 文章写作最佳实践 文章结构\n使用清晰的标题层级 添加适当的空行提高可读性 使用列表和表格组织内容 添加代码块时指定语言 Front Matter 配置\n注意：使用主题后，以下配置会自动添加到文章头部，无需手动添加\n1 2 3 4 5 6 7 8 9 10 11 12 13 --- title: \u0026#34;文章标题\u0026#34; description: \u0026#34;文章描述\u0026#34; date: 2024-03-19T12:00:00+08:00 image: /images/cover.jpg categories: - 分类1 - 分类2 tags: - 标签1 - 标签2 draft: false --- 图片管理\n使用相对路径引用图片 图片放在 static/images/ 目录下 使用 Hugo 的图片处理功能优化图片 为图片添加描述性文本，帮助搜索引擎和屏幕阅读器理解图片内容 代码块使用\n基本的 Markdown 代码块语法：\n```python def hello_world(): print(\"Hello, Hugo!\") ``` 命令行示例语法：\n```bash # 命令行示例 hugo new post/my-first-post.md ``` 链接管理\n使用相对路径链接内部文章 使用 [text]({{\u0026lt; relref \u0026ldquo;/post/file.md\u0026rdquo; \u0026gt;}}) 外部链接添加 target=\u0026quot;_blank\u0026quot; 和 rel=\u0026quot;noopener\u0026quot; 性能优化建议 构建优化\n使用 --minify 压缩输出 合理使用 partial 和 shortcode 避免过度使用 JavaScript 使用 Hugo Pipes 处理资源 图片优化\n使用 WebP 格式 实现响应式图片 使用 Hugo 的图片处理功能 合理设置图片尺寸 缓存优化\n配置浏览器缓存 使用 CDN 加速 优化资源加载顺序 主题配置 主题选择建议 选择标准\n活跃度：查看主题的更新频率和 star 数 文档完整性：是否有详细的配置文档 响应式设计：是否支持移动端 功能丰富度：是否满足需求 定制难度：是否易于修改 推荐主题\nStack：现代化设计，功能丰富 PaperMod：简洁优雅，性能优秀 LoveIt：中文友好，功能完善 DoIt：适合技术博客 主题安装 主题使用请查看这篇文章文档\n常见问题 1. 构建失败 问题：执行 hugo 命令时报错 解决方案：\n检查 Hugo 版本是否兼容 检查主题版本是否最新 检查配置文件语法 查看详细错误日志 2. 图片无法显示 问题：本地预览正常，部署后图片无法显示 解决方案：\n检查图片路径是否正确 确保图片文件已提交到仓库 使用相对路径引用图片 检查图片文件名大小写 3. 主题样式丢失 问题：部署后主题样式完全丢失 解决方案：\n检查主题是否正确安装 检查主题版本兼容性 检查主题资源文件是否完整 检查构建命令是否正确 4. 自定义域名无法访问 问题：配置自定义域名后无法访问 解决方案：\n检查 DNS 配置是否正确 等待 DNS 生效 检查 SSL 证书配置 检查 GitHub Pages 设置 5. 评论系统不显示 问题：配置评论系统后不显示 解决方案：\n检查评论系统配置是否正确 检查 API 密钥是否有效 检查评论系统服务是否正常 检查浏览器控制台错误 维护建议 定期更新\n更新 Hugo 到最新版本 更新主题到最新版本 检查依赖包更新 更新评论系统配置 内容备份\n定期备份 content 目录 备份配置文件 备份自定义主题文件 使用 Git 进行版本控制 性能监控\n使用 Google Analytics 监控访问 使用 PageSpeed Insights 检查性能 监控服务器响应时间 检查资源加载情况 安全维护\n定期更新依赖包 检查安全漏洞 更新 SSL 证书 保护敏感信息 相关资源 Hugo 官方文档 Hugo 主题列表 Hugo 论坛 Hugo GitHub ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"Hugo 搭建个人博客"},{"content":"什么是 PowerToys？ PowerToys 是微软开发的一套实用工具集，旨在帮助高级用户调整和简化 Windows 体验以提高工作效率。它包含多个实用工具，如快速启动器、窗口管理、颜色选择器等。\n安装方法 使用 Scoop 安装 1 scoop install powertoys 使用 Winget 安装 1 winget install Microsoft.PowerToys 手动安装 访问 PowerToys GitHub 发布页面 下载最新版本的安装包 运行安装程序 核心功能配置 1. 颜色选择器 (Color Picker) 快捷键：Win + Shift + C 功能：快速获取屏幕任意位置的颜色值 支持格式：HEX、RGB、HSL、CMYK 等 2. PowerToys Run 快捷键：Alt + Space 功能：快速启动应用程序和文件 特点： 支持模糊搜索 可安装插件扩展功能 支持计算器和单位转换 3. File Locksmith 功能：显示正在使用文件的进程 使用方法： 右键点击文件 选择\u0026quot;查看哪些进程正在使用此文件\u0026quot; 查看并管理相关进程 4. FancyZones 功能：增强的窗口管理工具 特点： 自定义窗口布局 支持多显示器 可保存常用布局 插件安装与配置 PowerToys Run Everything 插件 安装插件\n1 scoop install everything-powertoys 配置步骤\n下载 Everything64.dll\n将 DLL 文件复制到 everything-powertoys 安装目录\n将插件复制到 PowerToys 插件目录：\n1 C:\\Users\\\u0026lt;用户名\u0026gt;\\AppData\\Local\\Microsoft\\PowerToys\\PowerToys Run\\Plugins 在 PowerToys Run 设置中：\n启用 Everything 插件 设置 Everything 运行路径 重启 PowerToys\n其他推荐插件 Window Walker\n快速切换窗口 支持模糊搜索 Registry Preview\n预览注册表文件 支持语法高亮 PowerRename\n批量重命名文件 支持正则表达式 快捷键设置 常用快捷键 Win + Shift + C：颜色选择器 Alt + Space：PowerToys Run Win + Shift + D：快速桌面 Win + Shift + T：文本提取器 自定义快捷键 打开 PowerToys 设置 选择\u0026quot;键盘管理器\u0026quot; 点击\u0026quot;添加新的快捷键\u0026quot; 设置快捷键组合和对应功能 性能优化 启动项管理 打开 PowerToys 设置 选择\u0026quot;启动项\u0026quot; 配置开机自启动项 资源占用 建议关闭不常用的功能 定期检查后台进程 根据需要调整功能配置 常见问题 1. 插件无法加载 检查插件安装路径 确认 DLL 文件位置 验证插件兼容性 2. 快捷键冲突 检查系统快捷键设置 调整 PowerToys 快捷键 避免与其他软件冲突 3. 性能问题 关闭不必要的功能 更新到最新版本 检查系统资源占用 参考资源 PowerToys 官方文档 PowerToys GitHub PowerToys 插件市场 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/powertoys-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"PowerToys 使用指南"},{"content":"为什么需要管理C盘空间？ 在 Windows 系统中，C 盘作为系统主分区，存储着：\n操作系统文件（Windows 文件夹） 系统程序（Program Files） 用户配置文件 系统引导文件 C盘空间不足可能导致：\n系统运行变慢 无法安装新软件 系统更新失败 文件损坏 系统不稳定 空间占用分析 1. 软件安装位置 很多软件默认安装在C盘的原因：\n标准化与兼容性\n默认安装到 Program Files 文件夹 更好的系统整合性 避免兼容性问题 访问权限与路径依赖\nC盘是系统管理员控制的分区 软件依赖特定路径存储资源 系统API默认路径指向C盘 2. 应用数据存储 即使软件安装在其他盘，仍可能在C盘占用空间：\n用户配置文件（C:\\Users\\用户名\\AppData） 缓存文件 临时文件 日志文件 空间优化方案 1. 软件安装优化 使用包管理器安装\n推荐使用 Scoop 安装软件 可自定义安装路径 便于管理和更新 自定义安装路径\n安装时修改默认路径 选择其他磁盘分区 避免安装在C盘 2. 应用数据迁移 使用 WizTree 分析空间占用 安装 WizTree\n1 scoop install wiztree 扫描分析\n快速扫描磁盘 可视化空间占用 定位大文件/文件夹 常见大空间占用目录 开发工具\nJetBrains IDE：C:\\Users\\用户名\\AppData\\Local\\JetBrains Unity：C:\\Users\\用户名\\AppData\\Local\\Unity Visual Studio：C:\\Users\\用户名\\AppData\\Local\\Microsoft\\VisualStudio 应用缓存\nChrome：C:\\Users\\用户名\\AppData\\Local\\Google\\Chrome\\User Data Firefox：C:\\Users\\用户名\\AppData\\Local\\Mozilla\\Firefox\\Profiles Edge：C:\\Users\\用户名\\AppData\\Local\\Microsoft\\Edge\\User Data 迁移步骤 移动文件夹\n1 2 3 4 5 # 创建目标目录 New-Item -ItemType Directory -Force -Path \u0026#34;G:\\AppData\\JetBrains\u0026#34; # 移动文件夹 Move-Item -Path \u0026#34;C:\\Users\\用户名\\AppData\\Local\\JetBrains\u0026#34; -Destination \u0026#34;G:\\AppData\\JetBrains\u0026#34; 创建符号链接\n1 2 # 需要管理员权限 New-Item -ItemType SymbolicLink -Path \u0026#34;C:\\Users\\用户名\\AppData\\Local\\JetBrains\u0026#34; -Target \u0026#34;G:\\AppData\\JetBrains\u0026#34; 3. 系统清理 清理临时文件\n1 2 3 4 5 # 清理 Windows 临时文件 Remove-Item -Path \u0026#34;$env:TEMP\\*\u0026#34; -Recurse -Force # 清理系统临时文件 Remove-Item -Path \u0026#34;C:\\Windows\\Temp\\*\u0026#34; -Recurse -Force 清理系统更新缓存\n1 2 # 清理 Windows 更新缓存 Remove-Item -Path \u0026#34;C:\\Windows\\SoftwareDistribution\\Download\\*\u0026#34; -Recurse -Force 清理回收站\n1 2 # 清空回收站 Clear-RecycleBin -Force 注意事项 备份重要数据\n迁移前备份重要文件 记录原始路径 保存配置信息 权限管理\n使用管理员权限执行命令 确保目标路径有写入权限 检查文件访问权限 系统稳定性\n迁移后测试软件功能 检查系统更新 监控系统性能 定期维护 定期清理\n清理临时文件 删除不需要的软件 整理用户文件 空间监控\n使用 WizTree 定期扫描 监控空间变化 及时处理大文件 软件管理\n及时更新软件 卸载不常用软件 使用包管理器管理 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/windows-c%E7%9B%98%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/","title":"Windows C盘空间优化指南"},{"content":"简介 Windows Terminal 是一个现代化、多标签的终端应用程序，专为使用命令行工具设计。它提供了许多强大且灵活的功能，可以替代经典的命令提示符和 PowerShell 窗口。\n主要特性：\n多标签页支持 分屏功能 自定义主题 丰富的快捷键 支持多种 Shell（PowerShell、CMD、WSL 等） 安装 安装方式 Microsoft Store\n直接安装 优点：自动更新，安装简单 GitHub 发布页\n下载最新版本 优点：可以获取最新特性 包管理器安装（推荐）\n1 2 3 4 5 # 使用 scoop 安装 scoop install windows-terminal # 使用 winget 安装 winget install Microsoft.WindowsTerminal 安装 PowerShell Core Windows Terminal 推荐使用 PowerShell Core（跨平台版本）而不是系统自带的 PowerShell：\n1 2 # 使用 scoop 安装 scoop install powershell 基础配置 常用快捷键 功能 快捷键 新建标签页 Ctrl + Shift + T 切换标签页 Ctrl + Tab 右分屏 Alt + Shift + + 下分屏 Alt + Shift + - 打开设置 Ctrl + , 打开命令面板 Ctrl + Shift + P 自定义快捷键 在 settings.json 中配置自定义快捷键：\n1 2 3 4 5 6 7 8 9 { \u0026#34;keybindings\u0026#34;: [ { \u0026#34;command\u0026#34;: \u0026#34;newTab\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+shift+p\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;PowerShell\u0026#34; } ] } 美化配置 1. 配置字体 下载等宽字体\n推荐使用 Cascadia Code PL 其他选择：JetBrains Mono、Fira Code 配置字体设置\n1 2 3 4 5 6 7 8 { \u0026#34;defaults\u0026#34;: { \u0026#34;font\u0026#34;: { \u0026#34;face\u0026#34;: \u0026#34;Cascadia Code PL\u0026#34;, \u0026#34;size\u0026#34;: 10.0 } } } 2. 配置 oh-my-posh 安装 oh-my-posh 1 2 3 4 5 6 7 8 # 使用 winget 安装（推荐） winget install JanDeDobbeleer.OhMyPosh -l D:\\Tools\\oh-my-posh # 使用 scoop 安装 scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json # 验证安装 oh-my-posh --version 更新 oh-my-posh 1 2 3 4 5 # 使用 winget 更新 winget upgrade JanDeDobbeleer.OhMyPosh # 使用 scoop 更新 scoop update oh-my-posh 配置主题 下载主题\n主题预览 主题仓库 推荐主题： powerlevel10k_lean cobalt2 保存主题文件\n1 2 3 4 5 # 创建主题目录 New-Item -ItemType Directory -Force -Path \u0026#34;D:\\Tools\\oh-my-posh\\themes\u0026#34; # 下载主题文件 Invoke-WebRequest -Uri \u0026#34;https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/powerlevel10k_lean.omp.json\u0026#34; -OutFile \u0026#34;D:\\Tools\\oh-my-posh\\themes\\powerlevel10k_lean.omp.json\u0026#34; 配置 PowerShell 配置文件\n1 2 3 4 5 # 创建配置文件 if (!(Test-Path -Path $PROFILE)) { New-Item -Type File -Path $PROFILE -Force } # 编辑配置文件 code $PROFILE 添加配置内容\n1 2 3 4 5 6 7 8 9 10 # 初始化 oh-my-posh oh-my-posh init pwsh --config D:\\Tools\\oh-my-posh\\themes\\powerlevel10k_lean.omp.json | Invoke-Expression # 配置命令补全 Import-Module PSReadLine Set-PSReadLineOption -PredictionSource History Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete # 清屏 cls 验证配置\n1 2 3 4 5 # 重新加载配置文件 . $PROFILE # 检查 oh-my-posh 是否正确加载 $env:POSH_THEMES_PATH 实用功能 1. 代理管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 开启代理 function proxy-on { param($proxy = \u0026#34;http://127.0.0.1:1080\u0026#34;) $env:http_proxy = $proxy $env:https_proxy = $proxy Write-Host \u0026#34;代理已开启: $proxy\u0026#34; } # 关闭代理 function proxy-off { $env:http_proxy = \u0026#34;\u0026#34; $env:https_proxy = \u0026#34;\u0026#34; Write-Host \u0026#34;代理已关闭\u0026#34; } 2. 快速打开文件夹 1 2 3 4 5 # 打开文件夹 function open { param($path = \u0026#34;.\u0026#34;) explorer.exe $path } 3. 环境变量管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 设置环境变量 function set-env { param( [string]$key, [string]$value, [string]$scope = \u0026#34;u\u0026#34; # u: 用户, m: 系统 ) if ($scope -eq \u0026#34;u\u0026#34;) { [System.Environment]::SetEnvironmentVariable($key, $value, \u0026#34;User\u0026#34;) } else { [System.Environment]::SetEnvironmentVariable($key, $value, \u0026#34;Machine\u0026#34;) } Write-Host \u0026#34;环境变量已设置: $key = $value\u0026#34; } 配置文件 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/windows-terminal-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Windows Terminal 使用指南"},{"content":"软件安装方式 Windows 系统安装应用的方式主要有以下几种：\n包管理器安装\n优点：自动化、便捷、可重复 缺点：部分软件可能不支持 适用场景：开发工具、常用软件 Microsoft Store 安装\n优点：安全、自动更新 缺点：软件数量有限 适用场景：UWP 应用、系统工具 安装包安装\n优点：最通用、功能完整 缺点：手动操作、可能捆绑 适用场景：大型软件、特殊软件 包管理器介绍 包管理器的优势 自动化管理\n一键安装/卸载 批量更新 依赖处理 版本控制 安全性\n官方源 签名验证 安全更新 便捷性\n命令行操作 配置备份 环境迁移 一致性\n统一安装流程 标准配置 可重复部署 Windows 主流包管理器 1. Scoop（推荐） 特点：\n绿色软件，无需管理员权限 用户目录安装，不影响系统 配置简单，支持多版本共存 软件库相对较少，更新可能不够及时 安装步骤：\n1 2 3 4 5 6 # 设置 PowerShell 执行策略 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser # 安装 Scoop irm get.scoop.sh -outfile \u0026#39;install.ps1\u0026#39; .\\install.ps1 -ScoopDir \u0026#39;D:\\Applications\\Scoop\u0026#39; -ScoopGlobalDir \u0026#39;F:\\GlobalScoopApps\u0026#39; -NoProxy 常用命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # 搜索软件 scoop search \u0026lt;app_name\u0026gt; # 安装软件 scoop install \u0026lt;app_name\u0026gt; # 更新软件 scoop update \u0026lt;app_name\u0026gt; # 卸载软件 scoop uninstall \u0026lt;app_name\u0026gt; # 查看已安装软件 scoop list # 高级命令 # 设置代理 scoop config proxy 127.0.0.1:1080 # 查看帮助 scoop --help # 查看版本 scoop --version # 查看缓存 scoop cache list # 清理缓存 scoop cache cleanup # 导出安装列表 scoop export \u0026gt; \u0026lt;file_name\u0026gt; # 导入安装列表 scoop import \u0026lt;file_name\u0026gt; # 清理未使用的应用 scoop cleanup # 重置 Scoop scoop reset Scoop 目录说明 Scoop 安装后会在指定目录创建以下文件夹：\napps：所有通过 scoop 安装的软件 buckets：软件仓库配置，默认包含 main 仓库 cache：下载的安装包临时存储 persist：用户数据持久化存储 shims：命令行工具软链接 仓库管理 添加仓库\n1 2 3 4 5 6 7 # 添加官方仓库 scoop bucket add extras scoop bucket add versions scoop bucket add java # 添加自定义仓库 scoop bucket add \u0026lt;仓库名\u0026gt; \u0026lt;仓库URL\u0026gt; 查看仓库\n1 2 3 4 5 # 列出所有仓库 scoop bucket list # 查看仓库软件 scoop search \u0026lt;软件名\u0026gt; 更新仓库\n1 2 3 4 5 # 更新所有仓库 scoop update # 更新特定仓库 scoop update \u0026lt;仓库名\u0026gt; 2. WinGet 特点：\n微软官方维护，安全性高 系统原生集成，无需额外安装 支持 Microsoft Store 和 UWP 应用 软件库较少，功能相对简单 安装方式：\nMicrosoft Store 安装\nGitHub 下载安装\n通过 Scoop 安装（推荐）：\n1 scoop install winget 常用命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 搜索软件 winget search \u0026lt;app_name\u0026gt; # 安装软件 winget install \u0026lt;app_name\u0026gt; # 指定安装路径 winget install -l \u0026lt;app_name\u0026gt; # 交互式安装 winget install -i \u0026lt;app_name\u0026gt; # 高级命令 # 查看已安装软件 winget list # 更新软件 winget upgrade # 卸载软件 winget uninstall \u0026lt;app_name\u0026gt; # 查看软件信息 winget show \u0026lt;app_name\u0026gt; # 导出已安装软件列表 winget export -o \u0026lt;file_name\u0026gt; # 从文件导入安装 winget import \u0026lt;file_name\u0026gt; 3. Chocolatey 特点：\n社区驱动，软件库最丰富 功能全面，支持多版本管理 需要管理员权限，配置较复杂 部分包更新不及时，安装较慢 安装方法：\n1 2 # 以管理员身份运行 PowerShell Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) 常用命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 搜索软件 choco search \u0026lt;app_name\u0026gt; # 安装软件 choco install \u0026lt;app_name\u0026gt; # 更新软件 choco upgrade \u0026lt;app_name\u0026gt; # 卸载软件 choco uninstall \u0026lt;app_name\u0026gt; # 查看已安装软件 choco list --local-only # 更新所有软件 choco upgrade all # 查看软件信息 choco info \u0026lt;app_name\u0026gt; 软件安装最佳实践 1. 包管理器安装 优先使用包管理器安装软件，特别是开发工具和常用软件。\n2. 安装包安装 对于无法通过包管理器安装的软件：\n下载来源\n官方网站 可信第三方 避免破解版 安装步骤\n修改安装路径 取消捆绑软件 注意安装选项 安装后检查\n验证功能 检查启动项 清理临时文件 推荐软件 开发工具 编辑器\nVSCode（scoop install vscode）：功能强大的代码编辑器，支持丰富的插件和扩展 Sublime Text（scoop install sublime-text）：轻量级高性能编辑器，适合快速编辑 终端工具\nWindows Terminal（scoop install windows-terminal）：现代化的终端模拟器，支持多标签和分屏 Git（scoop install git）：版本控制工具，必备开发工具 开发工具\nADB（scoop install adb）：Android 调试工具，用于移动应用开发 APKTool（scoop install apktool）：Android 应用反编译工具 系统工具 压缩工具\n7-Zip（scoop install 7zip）：高效的文件压缩工具，支持多种格式 搜索工具\nEverything（scoop install everything）：快速的文件搜索工具，支持实时索引 系统优化\nCCleaner（scoop install ccleaner）：系统清理和优化工具 实用工具 下载工具\nAria2（scoop install aria2）：多协议下载工具，支持断点续传 PDF阅读器\nFoxit Reader（scoop install foxit-pdf-reader）：轻量级 PDF 阅读器，支持编辑功能 视频播放器\nPotPlayer（scoop install potplayer）：功能强大的视频播放器，支持多种格式 截图工具\nShareX（scoop install sharex）：功能丰富的截图和录屏工具 自动化工具 快捷键工具 AutoHotkey（scoop install autohotkey）：强大的自动化脚本工具 PowerToys（scoop install powertoys）：微软官方工具集，提供多种系统增强功能 配置文件 AutoHotkey 配置 基本语法：\n1 2 3 4 5 6 7 # 代表 Win 键 ! 代表 Alt 键 ^ 代表 Ctrl 键 + 代表 Shift 键 :: 分隔符 run 运行命令 ; 注释 示例配置：\n1 2 3 4 5 6 7 8 # 打开网站 #g::run https://github.com # 打开应用 #v::run code # 快捷键组合 #!v::run notepad 配置下载 scoop 列表下载 autohotkey 配置下载 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/windows-%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/","title":"Windows 系统软件安装指南"},{"content":"准备工作 1. 备份重要数据 在重装系统前，请确保：\n备份重要文档、图片等个人文件 导出浏览器书签和密码 记录已安装的软件列表 保存系统激活信息（如果有） 2. 下载系统镜像 Windows 11 下载 访问官方下载页面 选择 Windows 11 版本（建议选择最新版本） 选择语言（建议选择简体中文） 点击下载按钮，等待下载完成 Windows 10 下载 访问官方下载页面 由于页面限制，需要修改浏览器 UA 才能下载 ISO 文件 修改 UA 方法：\nChrome 浏览器：\n打开开发者工具（F12） More Tools -\u0026gt; Network conditions User agent 修改为 BlackBerry-BB10 Edge 浏览器：\n打开开发者工具（F12） 在底部选择网络条件 将用户代理修改为 BlackBerry-BB10 修改 UA 后刷新页面，即可选择对应的 ISO 文件下载。\n3. 准备启动工具 下载 WePE（推荐使用最新版本） 准备一个 8GB 以上的 U 盘 使用 WePE 制作启动盘（注意：此过程会格式化 U 盘，请提前备份数据） 重装系统 1. 进入 BIOS 重启电脑 在开机时按特定按键进入 BIOS（常见按键：F2、F10、Del、Esc） 找到 Boot 选项 将 U 盘设置为第一启动项 保存设置并退出 2. 安装系统 进入 WinPE 系统 使用分区工具（如 DiskGenius）进行分区（如果需要） 运行系统安装程序 选择系统镜像文件 选择安装位置（通常是 C 盘） 等待安装完成 3. 首次启动设置 设置系统语言和输入法 创建用户账户 设置密码（建议设置） 配置隐私选项 等待系统完成初始化 4. 跳过联网激活（可选） Windows 11 首次启动时需要联网激活，可以通过以下方法跳过：\n在首次启动界面，按 Shift + F10 打开命令提示符 输入以下命令： 1 oobe\\bypassnro.cmd 系统会自动重启 重启后，在联网界面选择\u0026quot;我没有 Internet 连接\u0026quot; 继续完成设置即可 注意：跳过联网激活后，建议在系统设置完成后手动连接网络并激活系统。\n系统优化 1. 安装必要驱动 检查设备管理器 下载并安装主板驱动 安装显卡驱动 安装网卡驱动 安装其他设备驱动 2. 系统更新 检查 Windows 更新 安装所有重要更新 安装可选更新（根据需要） ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/windows-%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%8C%87%E5%8D%97/","title":"Windows 系统重装指南"},{"content":"什么是 WSL？ WSL (Windows Subsystem for Linux) 是微软开发的一个工具，允许用户在 Windows 系统上直接运行 Linux 二进制可执行文件。这意味着你可以在 Windows 上运行一个完整的 Linux 环境，而无需虚拟机或双启动配置。\nWSL 的主要优势 无缝集成\n直接在 Windows 上运行 Linux 环境 无需虚拟机或双启动配置 可以同时使用 Windows 和 Linux 的功能 开发效率\n支持 Linux 命令行工具（Bash、Git、SSH 等） 可以直接访问 Windows 文件系统 适合 Web 开发、数据科学等场景 性能优势\n比传统虚拟机更轻量级 启动速度快 资源占用少 WSL 版本对比 WSL 1 特点：轻量级，直接将 Linux 调用映射到 Windows 内核 优势： 启动速度快 适合文件操作较多的任务 与 Windows 文件系统集成更好 限制： 不支持完整的 Linux 内核功能 性能相对较低 WSL 2 特点：使用完整的 Linux 内核，基于轻量级虚拟机 优势： 更好的性能 完整的 Linux 内核兼容性 支持 Docker 等容器技术 限制： 启动时间稍长 需要更多系统资源 推荐：建议使用 WSL 2，因为它提供更好的性能和更完整的 Linux 功能支持。\n安装指南 系统要求 Windows 10 版本 2004 及以上（内部版本 19041 及以上） Windows 11 开启必要的 Windows 功能 1. 开启 Hyper-V 1 2 # 以管理员身份运行 PowerShell，执行以下命令 dism.exe /online /enable-feature /featurename:Microsoft-Hyper-V /all /norestart 2. 开启虚拟机平台 1 2 # 以管理员身份运行 PowerShell，执行以下命令 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 3. 开启 Windows Subsystem for Linux 1 2 # 以管理员身份运行 PowerShell，执行以下命令 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 注意：执行完这些命令后需要重启计算机。\n安装方式 1. 便捷安装（推荐） 使用 wsl 命令安装，参考官方文档：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 安装 Ubuntu（默认） wsl --install # 查看可下载的 Linux 发行版 wsl --list --online # 或使用简写 wsl -l -o # 安装指定发行版 wsl --install -d \u0026lt;Distribution Name\u0026gt; # 查看已安装的发行版和版本 wsl -l -v # 设置默认版本 wsl --set-default-version 2 # 推荐使用 WSL 2 # 删除 Linux 发行版 wsl --unregister \u0026lt;Distribution Name\u0026gt; 2. 手动安装 安装 WSL2 内核\n下载 WSL2 内核更新包 安装下载的更新包 设置 WSL 版本\n1 wsl --set-default-version 2 安装 Linux 发行版\n访问 Microsoft Store 选择并安装需要的 Linux 发行版 基础配置 1. 设置 root 用户 1 sudo passwd root 2. 配置代理 1 2 3 4 5 # 设置 HTTP 代理 export http_proxy=http://127.0.0.1:1080 # 设置 HTTPS 代理 export https_proxy=http://127.0.0.1:1080 3. 更新系统 1 2 sudo apt update sudo apt upgrade 终端美化 安装 oh-my-zsh 安装 zsh\n1 sudo apt-get install zsh 安装 oh-my-zsh\n1 2 3 4 5 6 7 8 9 10 11 # 克隆 oh-my-zsh 仓库 git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh # 复制配置文件 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc # 应用配置 source ~/.zshrc # 设置默认 shell chsh -s /bin/zsh 配置主题 安装 Powerlevel10k 主题\n1 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/.oh-my-zsh/themes/powerlevel10k 修改主题配置\n编辑 ~/.zshrc 文件\n设置主题：\n1 ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; 应用配置\n1 source ~/.zshrc 查看当前主题\n1 echo $ZSH_THEME 配置插件 内置插件\n插件目录：~/.oh-my-zsh/plugins\n编辑 ~/.zshrc 文件，添加需要的插件：\n1 plugins=(git zsh-syntax-highlighting) 第三方插件\n在 ~/.zshrc 文件中添加：\n1 source \u0026lt;/path/to/plugin\u0026gt; 常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 启动 WSL wsl # 启动指定发行版 wsl -d \u0026lt;Distribution Name\u0026gt; # 关闭 WSL wsl --shutdown # 查看 WSL 状态 wsl --status # 导出 WSL 发行版 wsl --export \u0026lt;Distribution Name\u0026gt; \u0026lt;FileName\u0026gt; # 导入 WSL 发行版 wsl --import \u0026lt;Distribution Name\u0026gt; \u0026lt;InstallLocation\u0026gt; \u0026lt;FileName\u0026gt; 参考资源 WSL 官方文档 oh-my-zsh 文档 Powerlevel10k 主题 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/wsl-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"WSL 使用指南"},{"content":"问题描述 在 Windows 系统中，即使你的账户是管理员账户，也可能无法直接访问 C:\\Program Files\\WindowsApps 文件夹。这是因为该文件夹受到特殊权限保护，属于系统受限区域，主要用于存储 Microsoft Store 应用程序的数据。为了防止意外修改或恶意操作，Windows 默认限制了对该文件夹的访问权限，即使是管理员用户也需要额外步骤才能进入。\n原因分析 权限限制\nWindowsApps 文件夹的所有权通常属于系统账户（如 TrustedInstaller） 普通管理员账户没有直接访问权限 系统默认限制了对该文件夹的访问 UAC（用户账户控制）\n即使使用管理员账户，UAC 可能仍然要求额外的权限提升 系统安全机制限制了对系统文件夹的直接访问 文件夹保护机制\n该文件夹默认是隐藏的 受到 Windows 文件保护机制的限制 属于系统关键目录 解决方案 步骤 1：显示隐藏文件夹 打开文件资源管理器 点击顶部菜单的\u0026quot;查看\u0026quot; \u0026gt; \u0026ldquo;选项\u0026rdquo; \u0026gt; \u0026ldquo;查看\u0026quot;选项卡 在\u0026quot;高级设置\u0026quot;中： 勾选\u0026quot;显示隐藏的文件、文件夹和驱动器\u0026rdquo; 取消勾选\u0026quot;隐藏受保护的操作系统文件\u0026quot; 点击\u0026quot;应用\u0026quot;和\u0026quot;确定\u0026quot; 步骤 2：获取文件夹访问权限 打开文件夹属性\n右键点击 C:\\Program Files\\WindowsApps 文件夹 选择\u0026quot;属性\u0026quot; 修改安全设置\n切换到\u0026quot;安全\u0026quot;选项卡 点击\u0026quot;高级\u0026quot;按钮 更改所有者\n在\u0026quot;高级安全设置\u0026quot;窗口中，检查\u0026quot;所有者\u0026quot;是否为 TrustedInstaller 点击\u0026quot;更改\u0026quot;所有者 输入你的用户名（例如：你的电脑名\\你的用户名） 点击\u0026quot;检查名称\u0026quot;确认 查看当前用户名\n1 2 # 在命令提示符或 PowerShell 中执行 whoami 应用权限更改\n勾选\u0026quot;替换子容器和对象的所有者\u0026quot; 点击\u0026quot;确定\u0026quot;保存更改 添加完全控制权限\n返回\u0026quot;安全\u0026quot;选项卡 点击\u0026quot;编辑\u0026quot;按钮 为你的账户添加\u0026quot;完全控制\u0026quot;权限 点击\u0026quot;应用\u0026quot;和\u0026quot;确定\u0026quot; 注意事项 谨慎操作\n修改系统文件夹权限可能导致系统问题 建议在修改前备份重要数据 如非必要，不建议修改系统文件夹权限 潜在风险\n修改系统文件夹可能导致应用程序无法正常运行 可能影响系统更新和应用程序更新 可能触发系统安全机制 最佳实践\n仅在必要时访问该文件夹 完成操作后建议恢复原始权限 保持系统安全性的同时满足访问需求 参考资源 Windows 文件权限管理 Windows 安全最佳实践 ","date":"2024-03-06T14:11:27+08:00","permalink":"https://imhy.top/p/%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE-windowsapps-%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","title":"无法访问 WindowsApps 文件夹的解决方案"},{"content":"问题背景 当 Unity 导出 Android APK 时，如果项目使用了大量的第三方 SDK 或库，很容易达到 Android 方法数 65536 的限制。这是因为：\nAndroid 的 DEX 文件格式限制每个 APK 最多包含 65536 个方法 现代游戏开发中经常使用多个第三方 SDK Unity 项目本身也会引入大量方法 开发环境 Unity 2022.3.46f1 Android Gradle Plugin 7.3.1 Android SDK 33 minSdkVersion 21 targetSdkVersion 33 MultiDex 解决方案 1. 基础配置 开启 Gradle 构建\n在 Unity 中：Edit \u0026gt; Project Settings \u0026gt; Player \u0026gt; Android 勾选 \u0026ldquo;Custom Main Gradle Template\u0026rdquo; 勾选 \u0026ldquo;Custom Gradle Properties Template\u0026rdquo; 配置 Gradle 文件\n路径：Assets/Plugins/Android/mainTemplate.gradle 1 2 3 4 5 6 7 8 9 10 android { defaultConfig { minSdkVersion 21 targetSdkVersion 33 multiDexEnabled true // 启用 R8 优化 minifyEnabled true proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-unity.txt\u0026#39; } } 2. 依赖配置 AndroidX 支持\n1 2 3 4 dependencies { implementation \u0026#39;androidx.multidex:multidex:2.0.1\u0026#39; // 其他依赖... } 旧版支持库\n1 2 3 4 dependencies { implementation \u0026#39;com.android.support:multidex:1.0.3\u0026#39; // 其他依赖... } 3. Application 配置 修改 Assets/Plugins/Android/AndroidManifest.xml：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; package=\u0026#34;com.yourcompany.gamename\u0026#34;\u0026gt; \u0026lt;application android:name=\u0026#34;androidx.multidex.MultiDexApplication\u0026#34; android:allowBackup=\u0026#34;true\u0026#34; android:icon=\u0026#34;@drawable/app_icon\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:theme=\u0026#34;@style/UnityThemeSelector\u0026#34;\u0026gt; \u0026lt;!-- 其他配置... --\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 性能优化 1. 启动优化 预加载配置\n1 2 3 4 5 6 android { defaultConfig { // 启用预加载 multiDexKeepProguard file(\u0026#39;multidex-config.pro\u0026#39;) } } 主 DEX 配置\n创建 multidex-config.pro 文件 指定需要预加载的类 2. 构建优化 R8 优化\n1 2 3 4 5 6 7 8 9 android { buildTypes { release { minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-unity.txt\u0026#39; } } } DEX 优化\n1 2 3 4 5 6 7 android { dexOptions { preDexLibraries true maxProcessCount 8 javaMaxHeapSize \u0026#34;4g\u0026#34; } } 注意事项 版本兼容\nAndroid 5.0 (API 21) 以上默认支持 MultiDex 低版本需要额外配置 性能影响\n首次启动时间可能增加 内存占用可能增加 需要合理优化 调试建议\n使用 Android Studio 的 APK Analyzer 监控启动时间 检查内存使用 参考资源 Google MultiDex 官方文档 Unity Android 构建文档 Android Gradle Plugin 文档 ","date":"2024-03-05T16:03:30+08:00","permalink":"https://imhy.top/p/unity-%E4%BD%BF%E7%94%A8-multidex-%E5%BA%93/","title":"Unity 使用 MultiDex 库"},{"content":"小游戏更新机制 微信小游戏开发文档中描述了两种更新机制：\n1. 静默更新 特点：无需用户操作，自动更新 时机：微信客户端会在多个时机检查更新 限制：无法立即影响所有用户 时间：最长 24 小时内完成更新 2. 启动时更新 特点：冷启动时检查更新 流程： 检查新版本 异步下载新版本 使用本地包启动 下次冷启动应用新版本 冷启动说明 根据小程序运行机制文档，冷启动是指：\n用户首次打开小游戏 小游戏被销毁后再次打开 注意：关闭小游戏并不会立即触发销毁，需要满足以下条件之一：\n进入后台一定时间 系统资源占用过高 强制更新原因 在某些情况下，我们需要强制用户更新到最新版本，主要包括：\n1. 功能兼容性 新版本包含重要的功能更新 旧版本可能无法正常运行新功能 需要确保所有用户使用相同版本的功能 2. 安全性考虑 修复了严重的安全漏洞 防止用户使用存在安全隐患的版本 保护用户数据和账号安全 3. 游戏平衡性 修复了影响游戏平衡的 bug 更新了游戏规则或机制 确保所有玩家在公平的环境下游戏 4. 运营需求 新版本包含重要的运营活动 需要统一用户版本以支持新活动 确保活动规则对所有玩家一致 5. 技术维护 修复了导致崩溃的严重 bug 优化了游戏性能 减少了服务器压力 强制更新实现 1. 基础实现 1 2 3 4 5 6 7 8 9 10 11 12 13 var updateManager = WX.GetUpdateManager(); updateManager.OnCheckForUpdate(res =\u0026gt; { // noting }); updateManager.OnUpdateFailed(res =\u0026gt; { // show error tips }); updateManager.OnUpdateReady(res =\u0026gt; { // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 updateManager.ApplyUpdate(); }); 参考资源 微信小游戏更新机制文档 微信小游戏运行机制文档 微信小游戏开发文档 ","date":"2024-03-05T16:03:30+08:00","permalink":"https://imhy.top/p/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7/","title":"微信小游戏版本升级"}]